# Native Data Connector code generator

The NDC code generator provides a set of tools to develop data connectors quickly. It's suitable for developers who create connectors for business logic functions (or action in GraphQL Engine v2). 

The generator is inspired by [ndc-typescript-deno](https://github.com/hasura/ndc-typescript-deno) and [ndc-nodejs-lambda](https://github.com/hasura/ndc-nodejs-lambda) that automatically infer TypeScript functions as NDC functions/procedures for use at runtime. It's possible to do this with Go via reflection. However, code generation is better for performance, type-safe, and no magic.

## How to Use

```bash
‚ùØ hasura-ndc-go -h
Usage: hasura-ndc-go <command>

Flags:
  -h, --help    Show context-sensitive help.

Commands:
  init --name=STRING --module=STRING
    Initialize an NDC connector boilerplate. For example:

        hasura-ndc-go init -n example -m github.com/foo/example

  generate
    Generate schema and implementation for the connector from functions.
```

## Command

### Initialize connector project

The `init` command generates a boilerplate project for connector development from [template](templates/new) with the following folder structure:

- `functions`: the folder contains query and mutation functions. The `generate` command will parse `.go` files in this folder.
- `types`: the folder contains reusable types such as `RawConfiguration`, `Configuration` and `State`.
- `connector.go`: parts of Connector methods, except `GetSchema`, `Query` and `Mutation` methods that will be generated by the `generate` command.
- `main.go`: the main function that runs the connector CLI.
- `go.mod`: the module file with required dependencies.
- `README.md`: the index README file.

### Generate queries and mutations

The `generate` command parses code in the `functions` folder, finds functions and types that are allowed to expose and generates following files:

- `schema.generated.json`: the generated connector schema in JSON format. 
- `connector.generated.go`: implement `GetSchema`, `Query` and `Mutation` methods with exposed functions.

## How it works

### Functions

Functions which are allowed to expose as queries or mutations must have `Function` or `Procedure` prefix. For example:

```go
// FunctionHello sends a hello message
func FunctionHello(ctx context.Context, state *types.State, arguments *HelloArguments) (*HelloResult, error)

// ProcedureCreateAuthor creates an author
func ProcedureCreateAuthor(ctx context.Context, state *types.State, arguments *CreateAuthorArguments) (*CreateAuthorResult, error)
```

A function must have 2 (no argument) or 3 parameters. `Context` and `State` are always present as 2 first parameters. The result is a tuple with a expected output and `error`. 

> [Function](https://hasura.github.io/ndc-spec/specification/schema/functions.html) is a type of Query and [Procedure](https://hasura.github.io/ndc-spec/specification/schema/procedures.html) is a type of mutation. [Collection](https://hasura.github.io/ndc-spec/specification/schema/collections.html) is usually used for database queries so it isn't used for business logic.

### Types

The tool only parses argument and return types of exposed functions to generate object type schemas. `json` tags will be read as the field name to be consistent with JSON Marshaller and Unmarshaller. For example, with the following type:

```go
type CreateAuthorResult struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}
```

the schema will be:

```json
{
  "fields": {
    "id": {
      "type": {
        "name": "Int",
        "type": "named"
      }
    },
    "name": {
      "type": {
        "name": "String",
        "type": "named"
      }
    }
  }
}
```

## Example

An example is generated [here](../example/codegen).