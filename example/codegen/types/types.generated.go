// Code generated by github.com/hasura/ndc-sdk-go/cmd/hasura-ndc-go, DO NOT EDIT.
package types

import (
	"encoding/json"
	"errors"
	"github.com/hasura/ndc-sdk-go/utils"
	"slices"
)

// FromValue decodes values from map
func (j *Author) FromValue(input map[string]any) error {
	var err error
	j.Author, err = utils.DecodeNullableObjectValue[Author](input, "author")
	if err != nil {
		return err
	}
	j.CreatedAt, err = utils.GetDateTime(input, "created_at")
	if err != nil {
		return err
	}
	j.ID, err = utils.GetString(input, "id")
	if err != nil {
		return err
	}
	j.Status, err = utils.DecodeNullableObjectValue[AuthorStatus](input, "status")
	if err != nil {
		return err
	}
	j.Tags, err = utils.GetStringSliceDefault(input, "tags")
	if err != nil {
		return err
	}
	return nil
}

// ToMap encodes the struct to a value map
func (j Author) ToMap() map[string]any {
	r := make(map[string]any)
	if j.Author != nil {
		r["author"] = (*j.Author)
	}
	r["created_at"] = j.CreatedAt
	r["id"] = j.ID
	r["status"] = j.Status
	r["tags"] = j.Tags

	return r
}

// ScalarName get the schema name of the scalar
func (j AuthorStatus) ScalarName() string {
	return "AuthorStatus"
}

const (
	AuthorStatusActive   AuthorStatus = "active"
	AuthorStatusInactive AuthorStatus = "inactive"
)

var enumValues_AuthorStatus = []AuthorStatus{AuthorStatusActive, AuthorStatusInactive}

// ParseAuthorStatus parses a AuthorStatus enum from string
func ParseAuthorStatus(input string) (AuthorStatus, error) {
	result := AuthorStatus(input)
	if !slices.Contains(enumValues_AuthorStatus, result) {
		return AuthorStatus(""), errors.New("failed to parse AuthorStatus, expect one of [active, inactive]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j AuthorStatus) IsValid() bool {
	return slices.Contains(enumValues_AuthorStatus, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorStatus) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseAuthorStatus(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *AuthorStatus) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseAuthorStatus(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}

// ScalarName get the schema name of the scalar
func (j CommentText) ScalarName() string {
	return "CommentString"
}

// ScalarName get the schema name of the scalar
func (j SomeEnum) ScalarName() string {
	return "SomeEnum"
}

const (
	SomeEnumFoo SomeEnum = "foo"
	SomeEnumBar SomeEnum = "bar"
)

var enumValues_SomeEnum = []SomeEnum{SomeEnumFoo, SomeEnumBar}

// ParseSomeEnum parses a SomeEnum enum from string
func ParseSomeEnum(input string) (SomeEnum, error) {
	result := SomeEnum(input)
	if !slices.Contains(enumValues_SomeEnum, result) {
		return SomeEnum(""), errors.New("failed to parse SomeEnum, expect one of [foo, bar]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j SomeEnum) IsValid() bool {
	return slices.Contains(enumValues_SomeEnum, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SomeEnum) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseSomeEnum(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *SomeEnum) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseSomeEnum(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}
