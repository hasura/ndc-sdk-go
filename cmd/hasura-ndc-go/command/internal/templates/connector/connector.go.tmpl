// Code generated by github.com/hasura/ndc-sdk-go/cmd/hasura-ndc-go, DO NOT EDIT.
package {{.PackageName}}

import (
  "context"
  _ "embed"
  "fmt"
	"log/slog"

  {{.Imports}}
  "github.com/hasura/ndc-sdk-go/schema"
  "github.com/hasura/ndc-sdk-go/utils"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

var schemaResponse *schema.RawSchemaResponse
var connectorQueryHandlers = []ConnectorQueryHandler{{.QueryHandlers}}
var connectorMutationHandlers = []ConnectorMutationHandler{{.MutationHandlers}}

// ConnectorQueryHandler abstracts the connector query handler 
type ConnectorQueryHandler interface {
	Query(ctx context.Context, state *{{.StateArgument}}, request *schema.QueryRequest, arguments map[string]any) (*schema.RowSet, error)
}

// ConnectorMutationHandler abstracts the connector mutation handler 
type ConnectorMutationHandler interface {
	Mutation(ctx context.Context, state *{{.StateArgument}}, request *schema.MutationOperation) (schema.MutationOperationResults, error)
}

{{ if (eq .SchemaFormat "go")}}
func init() {
	rawSchema, err := json.Marshal(GetConnectorSchema())
  if err != nil {
    panic(err)
  }
	schemaResponse, err = schema.NewRawSchemaResponse(rawSchema)
	if err != nil {
		panic(err)
	}
}
{{ else }}
//go:embed schema.generated.json
var rawSchema []byte
func init() {
	var err error
	schemaResponse, err = schema.NewRawSchemaResponse(rawSchema)
	if err != nil {
		panic(err)
	}
}
{{ end }}

// GetSchema gets the connector's schema.
func (c *Connector) GetSchema(ctx context.Context, configuration *types.Configuration, _ *{{.StateArgument}}) (schema.SchemaResponseMarshaler, error) {
	return schemaResponse, nil
}

// Query executes a query.
func (c *Connector) Query(ctx context.Context, configuration *types.Configuration, state *{{.StateArgument}}, request *schema.QueryRequest) (schema.QueryResponse, error) {
	if len(connectorQueryHandlers) == 0 {
		return nil, schema.UnprocessableContentError(fmt.Sprintf("unsupported query: %s", request.Collection), nil)
	}

	span := trace.SpanFromContext(ctx)
	requestVars := request.Variables
	varsLength := len(requestVars)
	if varsLength == 0 {
		requestVars = []schema.QueryRequestVariablesElem{make(schema.QueryRequestVariablesElem)}
		varsLength = 1
	}

	rowSets := make([]schema.RowSet, varsLength)
	for i, requestVar := range requestVars {
		childSpan := span
		childContext := ctx
		if varsLength > 1 {
			childContext, childSpan = state.Tracer.Start(ctx, fmt.Sprintf("execute_function_%d", i))
			defer childSpan.End()
		}

		result, err := c.execQuery(childContext, state, request, requestVar)
		if err != nil {
			if varsLength > 1 {
				childSpan.SetStatus(codes.Error, err.Error())
			}
			return nil, err
		}
		rowSets[i] = *result

		if varsLength > 1 {
			childSpan.End()
		}
	}

	return rowSets, nil
}

func (c *Connector) execQuery(ctx context.Context, state *{{.StateArgument}}, request *schema.QueryRequest, variables map[string]any) (*schema.RowSet, error) {
	rawArgs, err := utils.ResolveArgumentVariables(request.Arguments, variables)
	if err != nil {
		return nil, schema.UnprocessableContentError("failed to resolve argument variables", map[string]any{
			"cause": err.Error(),
		})
	}

	for _, handler := range connectorQueryHandlers {
		result, err := handler.Query(ctx, state, request, rawArgs)
		if err == nil {
			return result, nil
		}

		if err != utils.ErrHandlerNotfound {
			return nil, err
		}
	}
	return nil, schema.UnprocessableContentError(fmt.Sprintf("unsupported query: %s", request.Collection), nil)
}

// Mutation executes a mutation.
func (c *Connector) Mutation(ctx context.Context, configuration *types.Configuration, state *{{.StateArgument}}, request *schema.MutationRequest) (*schema.MutationResponse, error) {
	if len(connectorMutationHandlers) == 0 {
		return nil, schema.UnprocessableContentError("unsupported mutation", nil)
	}

	operationLen := len(request.Operations)
	operationResults := make([]schema.MutationOperationResults, operationLen)
	span := trace.SpanFromContext(ctx)

	for i, operation := range request.Operations {
		childSpan := span
		childContext := ctx
		if operationLen > 1 {
			childContext, childSpan = state.Tracer.Start(ctx, fmt.Sprintf("execute_operation_%d", i))
			defer childSpan.End()
		}
		childSpan.SetAttributes(
			attribute.String("operation.type", string(operation.Type)),
			attribute.String("operation.name", string(operation.Name)),
		)

		switch operation.Type {
		case schema.MutationOperationProcedure:
			result, err := c.execProcedure(childContext, state, &operation)
			if err != nil {
				if operationLen > 1 {
					childSpan.SetStatus(codes.Error, err.Error())
				}
				return nil, err
			}
			operationResults[i] = result
			if operationLen > 1 {
				childSpan.End()
			}
		default:
			return nil, schema.UnprocessableContentError(fmt.Sprintf("invalid operation type: %s", operation.Type), nil)
		}
	}

	return &schema.MutationResponse{
		OperationResults: operationResults,
	}, nil
}

func (c *Connector) execProcedure(ctx context.Context, state *{{.StateArgument}}, operation *schema.MutationOperation) (schema.MutationOperationResults, error) {
	for _, handler := range connectorMutationHandlers {
		result, err := handler.Mutation(ctx, state, operation)
		if err == nil {
			return result, nil
		}
		if err != utils.ErrHandlerNotfound {
			return nil, err
		}
	}

	return nil, schema.UnprocessableContentError(fmt.Sprintf("unsupported procedure operation: %s", operation.Name), nil)
}