// Code generated by github.com/hasura/ndc-sdk-go/codegen, DO NOT EDIT.
package functions
import (
  "github.com/hasura/ndc-sdk-go/utils"
)
// FromValue decodes values from map
func (j *GetArticlesArguments) FromValue(input map[string]any) error {
  var err error
  err = utils.DecodeObjectValue(&j.Comment, input, "Comment")
  if err != nil {
    return err
  }
  j.Limit, err = utils.GetFloat[float64](input, "Limit")
  if err != nil {
    return err
  }
	j.Uint, err = utils.GetUint[uint](input, "Uint")
	if err != nil {
		return err
	}
  j.NullableStr, err = utils.GetStringPtr(input, "nullable_str")
  if err != nil {
    return err
  }
  return nil
}
// ToMap encodes the struct to a value map
func (j Author) ToMap() map[string]any {
  result := map[string]any{
    "created_at": j.CreatedAt,
    "duration": j.Duration,
    "id": j.ID,
  }
  return result
}
// ToMap encodes the struct to a value map
func (j CreateArticleResult) ToMap() map[string]any {
  result := map[string]any{
    "authors": utils.EncodeMaps(j.Authors),
    "id": j.ID,
  }
  return result
}
// ToMap encodes the struct to a value map
func (j CreateAuthorResult) ToMap() map[string]any {
  result := map[string]any{
    "created_at": j.CreatedAt,
    "id": j.ID,
    "name": j.Name,
  }
  return result
}
// ToMap encodes the struct to a value map
func (j GetArticlesResult) ToMap() map[string]any {
	var result_Location map[string]any
	if j.Location != nil {
    result_Location = map[string]any{
    "Lat": j.Location.Lat,
    "Long": j.Location.Long,
  }
	}
  result_Comments := make([]map[string]any, len(j.Comments))
	for i := range j.Comments {
  item := map[string]any{
    "content": j.Comments[i].Content,
  }
    result_Comments[i] = item
	}
	result_Author := map[string]any{
		"created_at": j.Author.CreatedAt,
		"decimal": j.Author.Decimal,
		"id": j.Author.ID,
	}
	result := map[string]any{
		"author": result_Author,
		"Comments": result_Comments,
		"id": j.ID,
		"Location": result_Location,
		"Name": j.Name,
	}
	return result
}
// ToMap encodes the struct to a value map
func (j HelloResult) ToMap() map[string]any {
  result := map[string]any{
    "foo": j.Foo,
    "id": j.ID,
    "num": j.Num,
    "text": j.Text,
  }
  return result
}
// ScalarName get the schema name of the scalar
func (j CommentText) ScalarName() string {
  return "CommentString"
}
// ScalarName get the schema name of the scalar
func (j ScalarFoo) ScalarName() string {
  return "Foo"
}
