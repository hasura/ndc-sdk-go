// Code generated by github.com/hasura/ndc-sdk-go/codegen, DO NOT EDIT.
package main

import (
  "context"
  _ "embed"
  "encoding/json"
  "fmt"

  {{.Imports}}
  "{{.Module}}/types"
  "github.com/hasura/ndc-sdk-go/schema"
  "github.com/hasura/ndc-sdk-go/utils"
)

//go:embed schema.generated.json
var rawSchema []byte
var schemaResponse schema.SchemaResponse

func init() {
  if err := json.Unmarshal(rawSchema, &schemaResponse); err != nil {
    panic(fmt.Errorf("failed to decode schema: %s", err))
  }
}

// GetSchema gets the connector's schema.
func (c *Connector) GetSchema(configuration *types.Configuration, state *types.State) (*schema.SchemaResponse, error) {
  return &schemaResponse, nil
}

// Query executes a query.
func (c *Connector) Query(ctx context.Context, configuration *types.Configuration, state *types.State, request *schema.QueryRequest) (schema.QueryResponse, error) {
  valueField, err := utils.EvalFunctionSelectionFieldValue(request)
  if err != nil {
 		return nil, schema.BadRequestError(err.Error(), nil)
  }
  requestVars := request.Variables
  if len(requestVars) == 0 {
    requestVars = []schema.QueryRequestVariablesElem{make(schema.QueryRequestVariablesElem)}
  }

  rowSets := make([]schema.RowSet, len(requestVars))
  for i, requestVar := range requestVars {
    result, err := execQuery(ctx, state, request, valueField, requestVar)
    if err != nil {
      return nil, err
    }
    rowSets[i] = schema.RowSet{
      Aggregates: schema.RowSetAggregates{},
      Rows: []map[string]any{
        {
          "__value": result,
        },
      },
    }
  }

  return rowSets, nil
}

// Mutation executes a mutation.
func (c *Connector) Mutation(ctx context.Context, configuration *types.Configuration, state *types.State, request *schema.MutationRequest) (*schema.MutationResponse, error) {
  operationResults := make([]schema.MutationOperationResults, len(request.Operations))

  for i, operation := range request.Operations {
    switch operation.Type {
    case schema.MutationOperationProcedure:
      result, err := execProcedure(ctx, state, &operation)
      if err != nil {
        return nil, err
      }
      operationResults[i] = result
    default:
      return nil, schema.BadRequestError(fmt.Sprintf("invalid operation type: %s", operation.Type), nil)
    }
  }

  return &schema.MutationResponse{
    OperationResults: operationResults,
  }, nil
}

func execQuery(ctx context.Context, state *types.State, request *schema.QueryRequest, queryFields schema.NestedField, variables map[string]any) (any, error) {

  switch request.Collection {
{{.Queries}}
  default:
    return nil, schema.BadRequestError(fmt.Sprintf("unsupported query: %s", request.Collection), nil)
  }
}

func execProcedure(ctx context.Context, state *types.State, operation *schema.MutationOperation) (schema.MutationOperationResults, error) {

  var result any
  switch operation.Name {
{{.Procedures}}
  default:
    return nil, schema.BadRequestError(fmt.Sprintf("unsupported procedure operation: %s", operation.Name), nil)
  }

  return schema.NewProcedureResult(result).Encode(), nil
}
