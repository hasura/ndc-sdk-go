// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

type AggregateCapabilities struct {
	// Does the connector support filtering based on aggregated values
	FilterBy *LeafCapability `json:"filter_by,omitempty" yaml:"filter_by,omitempty" mapstructure:"filter_by,omitempty"`

	// Does the connector support aggregations over groups
	GroupBy *GroupByCapabilities `json:"group_by,omitempty" yaml:"group_by,omitempty" mapstructure:"group_by,omitempty"`
}

type AggregateCapabilitiesSchemaInfo struct {
	// The scalar type which should be used for the return type of count (star_count
	// and column_count) operations.
	CountScalarType string `json:"count_scalar_type" yaml:"count_scalar_type" mapstructure:"count_scalar_type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AggregateCapabilitiesSchemaInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["count_scalar_type"]; raw != nil && !ok {
		return fmt.Errorf("field count_scalar_type in AggregateCapabilitiesSchemaInfo: required")
	}
	type Plain AggregateCapabilitiesSchemaInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AggregateCapabilitiesSchemaInfo(plain)
	return nil
}

// The definition of an aggregation function on a scalar type

type ArgumentInfo struct {
	// Argument description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of the type of this argument
	Type Type `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArgumentInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ArgumentInfo: required")
	}
	type Plain ArgumentInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ArgumentInfo(plain)
	return nil
}

// Describes the features of the specification which a data connector implements.
type Capabilities struct {
	// Mutation corresponds to the JSON schema field "mutation".
	Mutation MutationCapabilities `json:"mutation" yaml:"mutation" mapstructure:"mutation"`

	// Query corresponds to the JSON schema field "query".
	Query QueryCapabilities `json:"query" yaml:"query" mapstructure:"query"`

	// Does the connector support the relational mutation API? This feature is
	// experimental and subject to breaking changes within minor versions.
	RelationalMutation *RelationalMutationCapabilities `json:"relational_mutation,omitempty" yaml:"relational_mutation,omitempty" mapstructure:"relational_mutation,omitempty"`

	// Does the connector support the relational query API? This feature is
	// experimental and subject to breaking changes within minor versions.
	RelationalQuery *RelationalQueryCapabilities `json:"relational_query,omitempty" yaml:"relational_query,omitempty" mapstructure:"relational_query,omitempty"`

	// Relationships corresponds to the JSON schema field "relationships".
	Relationships *RelationshipCapabilities `json:"relationships,omitempty" yaml:"relationships,omitempty" mapstructure:"relationships,omitempty"`
}

type CapabilitiesResponse struct {
	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities Capabilities `json:"capabilities" yaml:"capabilities" mapstructure:"capabilities"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CapabilitiesResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["capabilities"]; raw != nil && !ok {
		return fmt.Errorf("field capabilities in CapabilitiesResponse: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in CapabilitiesResponse: required")
	}
	type Plain CapabilitiesResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CapabilitiesResponse(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Capabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["mutation"]; raw != nil && !ok {
		return fmt.Errorf("field mutation in Capabilities: required")
	}
	if _, ok := raw["query"]; raw != nil && !ok {
		return fmt.Errorf("field query in Capabilities: required")
	}
	type Plain Capabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Capabilities(plain)
	return nil
}

type CapabilitySchemaInfo struct {
	// Schema information relevant to query capabilities
	Query *QueryCapabilitiesSchemaInfo `json:"query,omitempty" yaml:"query,omitempty" mapstructure:"query,omitempty"`
}

type CaseWhen struct {
	// Then corresponds to the JSON schema field "then".
	Then RelationalExpression `json:"then" yaml:"then" mapstructure:"then"`

	// When corresponds to the JSON schema field "when".
	When RelationalExpression `json:"when" yaml:"when" mapstructure:"when"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CaseWhen) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["then"]; raw != nil && !ok {
		return fmt.Errorf("field then in CaseWhen: required")
	}
	if _, ok := raw["when"]; raw != nil && !ok {
		return fmt.Errorf("field when in CaseWhen: required")
	}
	type Plain CaseWhen
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CaseWhen(plain)
	return nil
}

type CollectionInfo struct {
	// Any arguments that this collection requires
	Arguments CollectionInfoArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// Description of the collection
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of the collection
	//
	// Note: these names are abstract - there is no requirement that this name
	// correspond to the name of an actual collection in the database.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Information about relational mutation capabilities for this collection
	RelationalMutations *RelationalMutationInfo `json:"relational_mutations,omitempty" yaml:"relational_mutations,omitempty" mapstructure:"relational_mutations,omitempty"`

	// The name of the collection's object type
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Any uniqueness constraints enforced on this collection
	UniquenessConstraints CollectionInfoUniquenessConstraints `json:"uniqueness_constraints" yaml:"uniqueness_constraints" mapstructure:"uniqueness_constraints"`
}

// Any arguments that this collection requires
type CollectionInfoArguments map[string]ArgumentInfo

// Any uniqueness constraints enforced on this collection
type CollectionInfoUniquenessConstraints map[string]UniquenessConstraint

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in CollectionInfo: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in CollectionInfo: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CollectionInfo: required")
	}
	if _, ok := raw["uniqueness_constraints"]; raw != nil && !ok {
		return fmt.Errorf("field uniqueness_constraints in CollectionInfo: required")
	}
	type Plain CollectionInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionInfo(plain)
	return nil
}

// The definition of a comparison operator on a scalar type

type DatePartScalarExpressionCapability struct {
	// Day corresponds to the JSON schema field "day".
	Day *LeafCapability `json:"day,omitempty" yaml:"day,omitempty" mapstructure:"day,omitempty"`

	// DayOfWeek corresponds to the JSON schema field "day_of_week".
	DayOfWeek *LeafCapability `json:"day_of_week,omitempty" yaml:"day_of_week,omitempty" mapstructure:"day_of_week,omitempty"`

	// DayOfYear corresponds to the JSON schema field "day_of_year".
	DayOfYear *LeafCapability `json:"day_of_year,omitempty" yaml:"day_of_year,omitempty" mapstructure:"day_of_year,omitempty"`

	// Epoch corresponds to the JSON schema field "epoch".
	Epoch *LeafCapability `json:"epoch,omitempty" yaml:"epoch,omitempty" mapstructure:"epoch,omitempty"`

	// Hour corresponds to the JSON schema field "hour".
	Hour *LeafCapability `json:"hour,omitempty" yaml:"hour,omitempty" mapstructure:"hour,omitempty"`

	// Microsecond corresponds to the JSON schema field "microsecond".
	Microsecond *LeafCapability `json:"microsecond,omitempty" yaml:"microsecond,omitempty" mapstructure:"microsecond,omitempty"`

	// Millisecond corresponds to the JSON schema field "millisecond".
	Millisecond *LeafCapability `json:"millisecond,omitempty" yaml:"millisecond,omitempty" mapstructure:"millisecond,omitempty"`

	// Minute corresponds to the JSON schema field "minute".
	Minute *LeafCapability `json:"minute,omitempty" yaml:"minute,omitempty" mapstructure:"minute,omitempty"`

	// Month corresponds to the JSON schema field "month".
	Month *LeafCapability `json:"month,omitempty" yaml:"month,omitempty" mapstructure:"month,omitempty"`

	// Nanosecond corresponds to the JSON schema field "nanosecond".
	Nanosecond *LeafCapability `json:"nanosecond,omitempty" yaml:"nanosecond,omitempty" mapstructure:"nanosecond,omitempty"`

	// Quarter corresponds to the JSON schema field "quarter".
	Quarter *LeafCapability `json:"quarter,omitempty" yaml:"quarter,omitempty" mapstructure:"quarter,omitempty"`

	// Second corresponds to the JSON schema field "second".
	Second *LeafCapability `json:"second,omitempty" yaml:"second,omitempty" mapstructure:"second,omitempty"`

	// Week corresponds to the JSON schema field "week".
	Week *LeafCapability `json:"week,omitempty" yaml:"week,omitempty" mapstructure:"week,omitempty"`

	// Year corresponds to the JSON schema field "year".
	Year *LeafCapability `json:"year,omitempty" yaml:"year,omitempty" mapstructure:"year,omitempty"`
}

type DatePartUnit string

const DatePartUnitDay DatePartUnit = "day"
const DatePartUnitDayOfWeek DatePartUnit = "day_of_week"
const DatePartUnitDayOfYear DatePartUnit = "day_of_year"
const DatePartUnitEpoch DatePartUnit = "epoch"
const DatePartUnitHour DatePartUnit = "hour"
const DatePartUnitMicrosecond DatePartUnit = "microsecond"
const DatePartUnitMillisecond DatePartUnit = "millisecond"
const DatePartUnitMinute DatePartUnit = "minute"
const DatePartUnitMonth DatePartUnit = "month"
const DatePartUnitNanosecond DatePartUnit = "nanosecond"
const DatePartUnitQuarter DatePartUnit = "quarter"
const DatePartUnitSecond DatePartUnit = "second"
const DatePartUnitWeek DatePartUnit = "week"
const DatePartUnitYear DatePartUnit = "year"

var enumValues_DatePartUnit = []interface{}{
	"year",
	"quarter",
	"month",
	"week",
	"day_of_week",
	"day_of_year",
	"day",
	"hour",
	"minute",
	"second",
	"microsecond",
	"millisecond",
	"nanosecond",
	"epoch",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatePartUnit) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DatePartUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DatePartUnit, v)
	}
	*j = DatePartUnit(v)
	return nil
}

type ErrorResponse struct {
	// Any additional structured information about the error
	Details interface{} `json:"details" yaml:"details" mapstructure:"details"`

	// A human-readable summary of the error
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ErrorResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["details"]; raw != nil && !ok {
		return fmt.Errorf("field details in ErrorResponse: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in ErrorResponse: required")
	}
	type Plain ErrorResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ErrorResponse(plain)
	return nil
}

type ExistsCapabilities struct {
	// Does the connector support named scopes in column references inside EXISTS
	// predicates
	NamedScopes *LeafCapability `json:"named_scopes,omitempty" yaml:"named_scopes,omitempty" mapstructure:"named_scopes,omitempty"`

	// Does the connector support ExistsInCollection::NestedCollection
	NestedCollections *LeafCapability `json:"nested_collections,omitempty" yaml:"nested_collections,omitempty" mapstructure:"nested_collections,omitempty"`

	// Does the connector support filtering over nested scalar arrays using
	// existential quantification. This means the connector must support
	// ExistsInCollection::NestedScalarCollection.
	NestedScalarCollections *LeafCapability `json:"nested_scalar_collections,omitempty" yaml:"nested_scalar_collections,omitempty" mapstructure:"nested_scalar_collections,omitempty"`

	// Does the connector support ExistsInCollection::Unrelated
	Unrelated *LeafCapability `json:"unrelated,omitempty" yaml:"unrelated,omitempty" mapstructure:"unrelated,omitempty"`
}

type ExplainResponse struct {
	// A list of human-readable key-value pairs describing a query execution plan. For
	// example, a connector for a relational database might return the generated SQL
	// and/or the output of the `EXPLAIN` command. An API-based connector might encode
	// a list of statically-known API calls which would be made.
	Details ExplainResponseDetails `json:"details" yaml:"details" mapstructure:"details"`
}

// A list of human-readable key-value pairs describing a query execution plan. For
// example, a connector for a relational database might return the generated SQL
// and/or the output of the `EXPLAIN` command. An API-based connector might encode
// a list of statically-known API calls which would be made.
type ExplainResponseDetails map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExplainResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["details"]; raw != nil && !ok {
		return fmt.Errorf("field details in ExplainResponse: required")
	}
	type Plain ExplainResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExplainResponse(plain)
	return nil
}

// The definition of an aggregation function on a scalar type

type ForeignKeyConstraint struct {
	// The columns on which you want want to define the foreign key. This is a mapping
	// between fields on object type to columns on the foreign collection. The column
	// on the foreign collection is specified via a field path (ie. an array of field
	// names that descend through nested object fields). The field path must only
	// contain a single item, meaning a column on the foreign collection's type,
	// unless the 'relationships.nested' capability is supported, in which case
	// multiple items can be used to denote a nested object field.
	ColumnMapping ForeignKeyConstraintColumnMapping `json:"column_mapping" yaml:"column_mapping" mapstructure:"column_mapping"`

	// The name of a collection
	ForeignCollection string `json:"foreign_collection" yaml:"foreign_collection" mapstructure:"foreign_collection"`
}

// The columns on which you want want to define the foreign key. This is a mapping
// between fields on object type to columns on the foreign collection. The column
// on the foreign collection is specified via a field path (ie. an array of field
// names that descend through nested object fields). The field path must only
// contain a single item, meaning a column on the foreign collection's type, unless
// the 'relationships.nested' capability is supported, in which case multiple items
// can be used to denote a nested object field.
type ForeignKeyConstraintColumnMapping map[string][]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForeignKeyConstraint) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["column_mapping"]; raw != nil && !ok {
		return fmt.Errorf("field column_mapping in ForeignKeyConstraint: required")
	}
	if _, ok := raw["foreign_collection"]; raw != nil && !ok {
		return fmt.Errorf("field foreign_collection in ForeignKeyConstraint: required")
	}
	type Plain ForeignKeyConstraint
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ForeignKeyConstraint(plain)
	return nil
}

type FunctionInfo struct {
	// Any arguments that this collection requires
	Arguments FunctionInfoArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// Description of the function
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of the function
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The name of the function's result type
	ResultType Type `json:"result_type" yaml:"result_type" mapstructure:"result_type"`
}

// Any arguments that this collection requires
type FunctionInfoArguments map[string]ArgumentInfo

// UnmarshalJSON implements json.Unmarshaler.
func (j *FunctionInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in FunctionInfo: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in FunctionInfo: required")
	}
	if _, ok := raw["result_type"]; raw != nil && !ok {
		return fmt.Errorf("field result_type in FunctionInfo: required")
	}
	type Plain FunctionInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FunctionInfo(plain)
	return nil
}

type Group struct {
	// Aggregates computed within this group
	Aggregates GroupAggregates `json:"aggregates" yaml:"aggregates" mapstructure:"aggregates"`

	// Values of dimensions which identify this group
	Dimensions []interface{} `json:"dimensions" yaml:"dimensions" mapstructure:"dimensions"`
}

// Aggregates computed within this group
type GroupAggregates map[string]interface{}

type GroupByCapabilities struct {
	// Does the connector support post-grouping predicates
	Filter *LeafCapability `json:"filter,omitempty" yaml:"filter,omitempty" mapstructure:"filter,omitempty"`

	// Does the connector support post-grouping ordering
	Order *LeafCapability `json:"order,omitempty" yaml:"order,omitempty" mapstructure:"order,omitempty"`

	// Does the connector support post-grouping pagination
	Paginate *LeafCapability `json:"paginate,omitempty" yaml:"paginate,omitempty" mapstructure:"paginate,omitempty"`
}

type GroupOrderBy struct {
	// The elements to order by, in priority order
	Elements []GroupOrderByElement `json:"elements" yaml:"elements" mapstructure:"elements"`
}

type GroupOrderByElement struct {
	// OrderDirection corresponds to the JSON schema field "order_direction".
	OrderDirection OrderDirection `json:"order_direction" yaml:"order_direction" mapstructure:"order_direction"`

	// Target corresponds to the JSON schema field "target".
	Target GroupOrderByTarget `json:"target" yaml:"target" mapstructure:"target"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupOrderByElement) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["order_direction"]; raw != nil && !ok {
		return fmt.Errorf("field order_direction in GroupOrderByElement: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in GroupOrderByElement: required")
	}
	type Plain GroupOrderByElement
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GroupOrderByElement(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupOrderBy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["elements"]; raw != nil && !ok {
		return fmt.Errorf("field elements in GroupOrderBy: required")
	}
	type Plain GroupOrderBy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GroupOrderBy(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Group) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["aggregates"]; raw != nil && !ok {
		return fmt.Errorf("field aggregates in Group: required")
	}
	if _, ok := raw["dimensions"]; raw != nil && !ok {
		return fmt.Errorf("field dimensions in Group: required")
	}
	type Plain Group
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Group(plain)
	return nil
}

type Grouping struct {
	// Aggregates to compute in each group
	Aggregates GroupingAggregates `json:"aggregates" yaml:"aggregates" mapstructure:"aggregates"`

	// Dimensions along which to partition the data
	Dimensions []Dimension `json:"dimensions" yaml:"dimensions" mapstructure:"dimensions"`

	// Optionally limit to N groups Only used if the
	// 'query.aggregates.group_by.paginate' capability is supported.
	Limit *int `json:"limit,omitempty" yaml:"limit,omitempty" mapstructure:"limit,omitempty"`

	// Optionally offset from the Nth group Only used if the
	// 'query.aggregates.group_by.paginate' capability is supported.
	Offset *int `json:"offset,omitempty" yaml:"offset,omitempty" mapstructure:"offset,omitempty"`

	// Optionally specify how groups should be ordered Only used if the
	// 'query.aggregates.group_by.order' capability is supported.
	OrderBy *GroupOrderBy `json:"order_by" yaml:"order_by" mapstructure:"order_by"`

	// Optionally specify a predicate to apply after grouping rows. Only used if the
	// 'query.aggregates.group_by.filter' capability is supported.
	Predicate *GroupExpression `json:"predicate,omitempty" yaml:"predicate,omitempty" mapstructure:"predicate,omitempty"`
}

// Aggregates to compute in each group
type GroupingAggregates map[string]Aggregate

// Optionally specify a predicate to apply after grouping rows. Only used if the
// 'query.aggregates.group_by.filter' capability is supported.

// UnmarshalJSON implements json.Unmarshaler.
func (j *Grouping) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["aggregates"]; raw != nil && !ok {
		return fmt.Errorf("field aggregates in Grouping: required")
	}
	if _, ok := raw["dimensions"]; raw != nil && !ok {
		return fmt.Errorf("field dimensions in Grouping: required")
	}
	type Plain Grouping
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Limit != nil && 0 > *plain.Limit {
		return fmt.Errorf("field %s: must be >= %v", "limit", 0)
	}
	if plain.Offset != nil && 0 > *plain.Offset {
		return fmt.Errorf("field %s: must be >= %v", "offset", 0)
	}
	*j = Grouping(plain)
	return nil
}

type JoinOn struct {
	// Left corresponds to the JSON schema field "left".
	Left RelationalExpression `json:"left" yaml:"left" mapstructure:"left"`

	// Right corresponds to the JSON schema field "right".
	Right RelationalExpression `json:"right" yaml:"right" mapstructure:"right"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JoinOn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["left"]; raw != nil && !ok {
		return fmt.Errorf("field left in JoinOn: required")
	}
	if _, ok := raw["right"]; raw != nil && !ok {
		return fmt.Errorf("field right in JoinOn: required")
	}
	type Plain JoinOn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = JoinOn(plain)
	return nil
}

// A unit value to indicate a particular leaf capability is supported. This is an
// empty struct to allow for future sub-capabilities.
type LeafCapability struct {
}

type MutationCapabilities struct {
	// Does the connector support explaining mutations
	Explain *LeafCapability `json:"explain,omitempty" yaml:"explain,omitempty" mapstructure:"explain,omitempty"`

	// Does the connector support executing multiple mutations in a transaction.
	Transactional *LeafCapability `json:"transactional,omitempty" yaml:"transactional,omitempty" mapstructure:"transactional,omitempty"`
}

type MutationRequest struct {
	// The relationships between collections involved in the entire mutation request.
	// Only used if the 'relationships' capability is supported.
	CollectionRelationships MutationRequestCollectionRelationships `json:"collection_relationships" yaml:"collection_relationships" mapstructure:"collection_relationships"`

	// The mutation operations to perform
	Operations []MutationOperation `json:"operations" yaml:"operations" mapstructure:"operations"`

	// Values to be provided to request-level arguments.
	RequestArguments MutationRequestRequestArguments `json:"request_arguments,omitempty" yaml:"request_arguments,omitempty" mapstructure:"request_arguments,omitempty"`
}

// The relationships between collections involved in the entire mutation request.
// Only used if the 'relationships' capability is supported.
type MutationRequestCollectionRelationships map[string]Relationship

// Values to be provided to request-level arguments.
type MutationRequestRequestArguments map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MutationRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collection_relationships"]; raw != nil && !ok {
		return fmt.Errorf("field collection_relationships in MutationRequest: required")
	}
	if _, ok := raw["operations"]; raw != nil && !ok {
		return fmt.Errorf("field operations in MutationRequest: required")
	}
	type Plain MutationRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MutationRequest(plain)
	return nil
}

type MutationResponse struct {
	// The results of each mutation operation, in the same order as they were received
	OperationResults []MutationOperationResults `json:"operation_results" yaml:"operation_results" mapstructure:"operation_results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MutationResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["operation_results"]; raw != nil && !ok {
		return fmt.Errorf("field operation_results in MutationResponse: required")
	}
	type Plain MutationResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MutationResponse(plain)
	return nil
}

type NestedArrayFilterByCapabilities struct {
	// Does the connector support filtering over nested arrays by checking if the
	// array contains a value. This must be supported for all types that can be
	// contained in an array that implement an 'eq' comparison operator.
	Contains *LeafCapability `json:"contains,omitempty" yaml:"contains,omitempty" mapstructure:"contains,omitempty"`

	// Does the connector support filtering over nested arrays by checking if the
	// array is empty. This must be supported no matter what type is contained in the
	// array.
	IsEmpty *LeafCapability `json:"is_empty,omitempty" yaml:"is_empty,omitempty" mapstructure:"is_empty,omitempty"`
}

type NestedFieldCapabilities struct {
	// Does the connector support aggregating values within nested fields
	Aggregates *LeafCapability `json:"aggregates,omitempty" yaml:"aggregates,omitempty" mapstructure:"aggregates,omitempty"`

	// Does the connector support filtering by values of nested fields
	FilterBy *NestedFieldFilterByCapabilities `json:"filter_by,omitempty" yaml:"filter_by,omitempty" mapstructure:"filter_by,omitempty"`

	// Does the connector support nested collection queries using
	// `NestedField::NestedCollection`
	NestedCollections *LeafCapability `json:"nested_collections,omitempty" yaml:"nested_collections,omitempty" mapstructure:"nested_collections,omitempty"`

	// Does the connector support ordering by values of nested fields
	OrderBy *LeafCapability `json:"order_by" yaml:"order_by" mapstructure:"order_by"`
}

type NestedFieldFilterByCapabilities struct {
	// Does the connector support filtering over nested arrays (ie.
	// Expression::ArrayComparison)
	NestedArrays *NestedArrayFilterByCapabilities `json:"nested_arrays,omitempty" yaml:"nested_arrays,omitempty" mapstructure:"nested_arrays,omitempty"`
}

type NestedRelationshipCapabilities struct {
	// Does the connector support navigating a relationship from inside a nested
	// object inside a nested array
	Array *LeafCapability `json:"array,omitempty" yaml:"array,omitempty" mapstructure:"array,omitempty"`

	// Does the connector support filtering over a relationship that starts from
	// inside a nested object
	Filtering *LeafCapability `json:"filtering,omitempty" yaml:"filtering,omitempty" mapstructure:"filtering,omitempty"`

	// Does the connector support ordering over a relationship that starts from inside
	// a nested object
	Ordering *LeafCapability `json:"ordering,omitempty" yaml:"ordering,omitempty" mapstructure:"ordering,omitempty"`
}

type NullsSort string

const NullsSortNullsFirst NullsSort = "nulls_first"
const NullsSortNullsLast NullsSort = "nulls_last"

var enumValues_NullsSort = []interface{}{
	"nulls_first",
	"nulls_last",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NullsSort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NullsSort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NullsSort, v)
	}
	*j = NullsSort(v)
	return nil
}

// The definition of an object field
type ObjectField struct {
	// The arguments available to the field - Matches implementation from
	// CollectionInfo
	Arguments ObjectFieldArguments `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`

	// Description of this field
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The type of this field
	Type Type `json:"type" yaml:"type" mapstructure:"type"`
}

// The arguments available to the field - Matches implementation from
// CollectionInfo
type ObjectFieldArguments map[string]ArgumentInfo

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObjectField) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ObjectField: required")
	}
	type Plain ObjectField
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ObjectField(plain)
	return nil
}

// The definition of an object type
type ObjectType struct {
	// Description of this type
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Fields defined on this object type
	Fields ObjectTypeFields `json:"fields" yaml:"fields" mapstructure:"fields"`

	// Any foreign keys defined for this object type's columns
	ForeignKeys ObjectTypeForeignKeys `json:"foreign_keys" yaml:"foreign_keys" mapstructure:"foreign_keys"`
}

// Fields defined on this object type
type ObjectTypeFields map[string]ObjectField

// Any foreign keys defined for this object type's columns
type ObjectTypeForeignKeys map[string]ForeignKeyConstraint

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObjectType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["fields"]; raw != nil && !ok {
		return fmt.Errorf("field fields in ObjectType: required")
	}
	if _, ok := raw["foreign_keys"]; raw != nil && !ok {
		return fmt.Errorf("field foreign_keys in ObjectType: required")
	}
	type Plain ObjectType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ObjectType(plain)
	return nil
}

type OrderBy struct {
	// The elements to order by, in priority order
	Elements []OrderByElement `json:"elements" yaml:"elements" mapstructure:"elements"`
}

type OrderByElement struct {
	// OrderDirection corresponds to the JSON schema field "order_direction".
	OrderDirection OrderDirection `json:"order_direction" yaml:"order_direction" mapstructure:"order_direction"`

	// Target corresponds to the JSON schema field "target".
	Target OrderByTarget `json:"target" yaml:"target" mapstructure:"target"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrderByElement) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["order_direction"]; raw != nil && !ok {
		return fmt.Errorf("field order_direction in OrderByElement: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in OrderByElement: required")
	}
	type Plain OrderByElement
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OrderByElement(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrderBy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["elements"]; raw != nil && !ok {
		return fmt.Errorf("field elements in OrderBy: required")
	}
	type Plain OrderBy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OrderBy(plain)
	return nil
}

type OrderDirection string

const OrderDirectionAsc OrderDirection = "asc"
const OrderDirectionDesc OrderDirection = "desc"

var enumValues_OrderDirection = []interface{}{
	"asc",
	"desc",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrderDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OrderDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OrderDirection, v)
	}
	*j = OrderDirection(v)
	return nil
}

type PathElement struct {
	// Values to be provided to any collection arguments
	Arguments PathElementArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// Path to a nested field within an object column that must be navigated before
	// the relationship is navigated. Only non-empty if the 'relationships.nested'
	// capability is supported (plus perhaps one of the sub-capabilities, depending on
	// the feature using the PathElement).
	FieldPath []string `json:"field_path,omitempty" yaml:"field_path,omitempty" mapstructure:"field_path,omitempty"`

	// A predicate expression to apply to the target collection
	Predicate Expression `json:"predicate,omitempty" yaml:"predicate,omitempty" mapstructure:"predicate,omitempty"`

	// The name of the relationship to follow
	Relationship string `json:"relationship" yaml:"relationship" mapstructure:"relationship"`
}

// Values to be provided to any collection arguments
type PathElementArguments map[string]RelationshipArgument

// A predicate expression to apply to the target collection

// UnmarshalJSON implements json.Unmarshaler.
func (j *PathElement) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in PathElement: required")
	}
	if _, ok := raw["relationship"]; raw != nil && !ok {
		return fmt.Errorf("field relationship in PathElement: required")
	}
	type Plain PathElement
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PathElement(plain)
	return nil
}

type ProcedureInfo struct {
	// Any arguments that this collection requires
	Arguments ProcedureInfoArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// Column description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of the procedure
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The name of the result type
	ResultType Type `json:"result_type" yaml:"result_type" mapstructure:"result_type"`
}

// Any arguments that this collection requires
type ProcedureInfoArguments map[string]ArgumentInfo

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProcedureInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in ProcedureInfo: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ProcedureInfo: required")
	}
	if _, ok := raw["result_type"]; raw != nil && !ok {
		return fmt.Errorf("field result_type in ProcedureInfo: required")
	}
	type Plain ProcedureInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProcedureInfo(plain)
	return nil
}

type Query struct {
	// Aggregate fields of the query. Only used if the 'query.aggregates' capability
	// is supported.
	Aggregates QueryAggregates `json:"aggregates,omitempty" yaml:"aggregates,omitempty" mapstructure:"aggregates,omitempty"`

	// Fields of the query
	Fields QueryFields `json:"fields,omitempty" yaml:"fields,omitempty" mapstructure:"fields,omitempty"`

	// Optionally group and aggregate the selected rows. Only used if the
	// 'query.aggregates.group_by' capability is supported.
	Groups *Grouping `json:"groups,omitempty" yaml:"groups,omitempty" mapstructure:"groups,omitempty"`

	// Optionally limit to N results
	Limit *int `json:"limit,omitempty" yaml:"limit,omitempty" mapstructure:"limit,omitempty"`

	// Optionally offset from the Nth result
	Offset *int `json:"offset,omitempty" yaml:"offset,omitempty" mapstructure:"offset,omitempty"`

	// Optionally specify how rows should be ordered
	OrderBy *OrderBy `json:"order_by" yaml:"order_by" mapstructure:"order_by"`

	// Optionally specify a predicate to apply to the rows
	Predicate Expression `json:"predicate,omitempty" yaml:"predicate,omitempty" mapstructure:"predicate,omitempty"`
}

// Aggregate fields of the query. Only used if the 'query.aggregates' capability is
// supported.
type QueryAggregates map[string]Aggregate

type QueryCapabilities struct {
	// Does the connector support aggregate queries
	Aggregates *AggregateCapabilities `json:"aggregates,omitempty" yaml:"aggregates,omitempty" mapstructure:"aggregates,omitempty"`

	// Does the connector support EXISTS predicates
	Exists ExistsCapabilities `json:"exists,omitempty" yaml:"exists,omitempty" mapstructure:"exists,omitempty"`

	// Does the connector support explaining queries
	Explain *LeafCapability `json:"explain,omitempty" yaml:"explain,omitempty" mapstructure:"explain,omitempty"`

	// Does the connector support nested fields
	NestedFields NestedFieldCapabilities `json:"nested_fields,omitempty" yaml:"nested_fields,omitempty" mapstructure:"nested_fields,omitempty"`

	// Does the connector support queries which use variables
	Variables *LeafCapability `json:"variables" yaml:"variables" mapstructure:"variables"`
}

type QueryCapabilitiesSchemaInfo struct {
	// Schema information relevant to aggregate query capabilities
	Aggregates *AggregateCapabilitiesSchemaInfo `json:"aggregates,omitempty" yaml:"aggregates,omitempty" mapstructure:"aggregates,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryCapabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain QueryCapabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["exists"]; !ok || v == nil {
		plain.Exists = ExistsCapabilities{}
	}
	if v, ok := raw["nested_fields"]; !ok || v == nil {
		plain.NestedFields = NestedFieldCapabilities{}
	}
	*j = QueryCapabilities(plain)
	return nil
}

// Fields of the query
type QueryFields map[string]Field

// Optionally specify a predicate to apply to the rows

// This is the request body of the query POST endpoint
type QueryRequest struct {
	// Values to be provided to any collection arguments
	Arguments QueryRequestArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// The name of a collection
	Collection string `json:"collection" yaml:"collection" mapstructure:"collection"`

	// Any relationships between collections involved in the query request. Only used
	// if the 'relationships' capability is supported.
	CollectionRelationships QueryRequestCollectionRelationships `json:"collection_relationships" yaml:"collection_relationships" mapstructure:"collection_relationships"`

	// The query syntax tree
	Query Query `json:"query" yaml:"query" mapstructure:"query"`

	// Values to be provided to request-level arguments.
	RequestArguments QueryRequestRequestArguments `json:"request_arguments,omitempty" yaml:"request_arguments,omitempty" mapstructure:"request_arguments,omitempty"`

	// One set of named variables for each rowset to fetch. Each variable set should
	// be subtituted in turn, and a fresh set of rows returned. Only used if the
	// 'query.variables' capability is supported.
	Variables []QueryRequestVariablesElem `json:"variables" yaml:"variables" mapstructure:"variables"`
}

// Values to be provided to any collection arguments
type QueryRequestArguments map[string]Argument

// Any relationships between collections involved in the query request. Only used
// if the 'relationships' capability is supported.
type QueryRequestCollectionRelationships map[string]Relationship

// Values to be provided to request-level arguments.
type QueryRequestRequestArguments map[string]interface{}

type QueryRequestVariablesElem map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in QueryRequest: required")
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in QueryRequest: required")
	}
	if _, ok := raw["collection_relationships"]; raw != nil && !ok {
		return fmt.Errorf("field collection_relationships in QueryRequest: required")
	}
	if _, ok := raw["query"]; raw != nil && !ok {
		return fmt.Errorf("field query in QueryRequest: required")
	}
	type Plain QueryRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QueryRequest(plain)
	return nil
}

// Query responses may return multiple RowSets when using queries with variables.
// Else, there should always be exactly one RowSet
type QueryResponse []RowSet

// UnmarshalJSON implements json.Unmarshaler.
func (j *Query) UnmarshalJSON(b []byte) error {
	type Plain Query
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Limit != nil && 0 > *plain.Limit {
		return fmt.Errorf("field %s: must be >= %v", "limit", 0)
	}
	if plain.Offset != nil && 0 > *plain.Offset {
		return fmt.Errorf("field %s: must be >= %v", "offset", 0)
	}
	*j = Query(plain)
	return nil
}

type RelationalAggregateCapabilities struct {
	// Expression corresponds to the JSON schema field "expression".
	Expression RelationalExpressionCapabilities `json:"expression" yaml:"expression" mapstructure:"expression"`

	// GroupBy corresponds to the JSON schema field "group_by".
	GroupBy *LeafCapability `json:"group_by,omitempty" yaml:"group_by,omitempty" mapstructure:"group_by,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalAggregateCapabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["expression"]; raw != nil && !ok {
		return fmt.Errorf("field expression in RelationalAggregateCapabilities: required")
	}
	type Plain RelationalAggregateCapabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalAggregateCapabilities(plain)
	return nil
}

type RelationalAggregateExpressionCapabilities struct {
	// ApproxDistinct corresponds to the JSON schema field "approx_distinct".
	ApproxDistinct *LeafCapability `json:"approx_distinct,omitempty" yaml:"approx_distinct,omitempty" mapstructure:"approx_distinct,omitempty"`

	// ApproxPercentileCont corresponds to the JSON schema field
	// "approx_percentile_cont".
	ApproxPercentileCont *LeafCapability `json:"approx_percentile_cont,omitempty" yaml:"approx_percentile_cont,omitempty" mapstructure:"approx_percentile_cont,omitempty"`

	// ArrayAgg corresponds to the JSON schema field "array_agg".
	ArrayAgg *RelationalOrderedAggregateFunctionCapabilities `json:"array_agg,omitempty" yaml:"array_agg,omitempty" mapstructure:"array_agg,omitempty"`

	// Avg corresponds to the JSON schema field "avg".
	Avg *LeafCapability `json:"avg,omitempty" yaml:"avg,omitempty" mapstructure:"avg,omitempty"`

	// BoolAnd corresponds to the JSON schema field "bool_and".
	BoolAnd *LeafCapability `json:"bool_and,omitempty" yaml:"bool_and,omitempty" mapstructure:"bool_and,omitempty"`

	// BoolOr corresponds to the JSON schema field "bool_or".
	BoolOr *LeafCapability `json:"bool_or,omitempty" yaml:"bool_or,omitempty" mapstructure:"bool_or,omitempty"`

	// Count corresponds to the JSON schema field "count".
	Count *LeafCapability `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// FirstValue corresponds to the JSON schema field "first_value".
	FirstValue *LeafCapability `json:"first_value,omitempty" yaml:"first_value,omitempty" mapstructure:"first_value,omitempty"`

	// LastValue corresponds to the JSON schema field "last_value".
	LastValue *LeafCapability `json:"last_value,omitempty" yaml:"last_value,omitempty" mapstructure:"last_value,omitempty"`

	// Max corresponds to the JSON schema field "max".
	Max *LeafCapability `json:"max,omitempty" yaml:"max,omitempty" mapstructure:"max,omitempty"`

	// Median corresponds to the JSON schema field "median".
	Median *LeafCapability `json:"median,omitempty" yaml:"median,omitempty" mapstructure:"median,omitempty"`

	// Min corresponds to the JSON schema field "min".
	Min *LeafCapability `json:"min,omitempty" yaml:"min,omitempty" mapstructure:"min,omitempty"`

	// Stddev corresponds to the JSON schema field "stddev".
	Stddev *LeafCapability `json:"stddev,omitempty" yaml:"stddev,omitempty" mapstructure:"stddev,omitempty"`

	// StddevPop corresponds to the JSON schema field "stddev_pop".
	StddevPop *LeafCapability `json:"stddev_pop,omitempty" yaml:"stddev_pop,omitempty" mapstructure:"stddev_pop,omitempty"`

	// StringAgg corresponds to the JSON schema field "string_agg".
	StringAgg *RelationalOrderedAggregateFunctionCapabilities `json:"string_agg,omitempty" yaml:"string_agg,omitempty" mapstructure:"string_agg,omitempty"`

	// StringAggWithSeparator corresponds to the JSON schema field
	// "string_agg_with_separator".
	StringAggWithSeparator *RelationalOrderedAggregateFunctionCapabilities `json:"string_agg_with_separator,omitempty" yaml:"string_agg_with_separator,omitempty" mapstructure:"string_agg_with_separator,omitempty"`

	// Sum corresponds to the JSON schema field "sum".
	Sum *LeafCapability `json:"sum,omitempty" yaml:"sum,omitempty" mapstructure:"sum,omitempty"`

	// Var corresponds to the JSON schema field "var".
	Var *LeafCapability `json:"var,omitempty" yaml:"var,omitempty" mapstructure:"var,omitempty"`
}

type RelationalAggregateFunctionCapabilities struct {
	// Distinct corresponds to the JSON schema field "distinct".
	Distinct *LeafCapability `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`
}

type RelationalCaseCapabilities struct {
	// Scrutinee corresponds to the JSON schema field "scrutinee".
	Scrutinee *LeafCapability `json:"scrutinee,omitempty" yaml:"scrutinee,omitempty" mapstructure:"scrutinee,omitempty"`
}

type RelationalComparisonExpressionCapabilities struct {
	// Between corresponds to the JSON schema field "between".
	Between *LeafCapability `json:"between,omitempty" yaml:"between,omitempty" mapstructure:"between,omitempty"`

	// Contains corresponds to the JSON schema field "contains".
	Contains *LeafCapability `json:"contains,omitempty" yaml:"contains,omitempty" mapstructure:"contains,omitempty"`

	// GreaterThan corresponds to the JSON schema field "greater_than".
	GreaterThan *LeafCapability `json:"greater_than,omitempty" yaml:"greater_than,omitempty" mapstructure:"greater_than,omitempty"`

	// GreaterThanEq corresponds to the JSON schema field "greater_than_eq".
	GreaterThanEq *LeafCapability `json:"greater_than_eq,omitempty" yaml:"greater_than_eq,omitempty" mapstructure:"greater_than_eq,omitempty"`

	// Ilike corresponds to the JSON schema field "ilike".
	Ilike *LeafCapability `json:"ilike,omitempty" yaml:"ilike,omitempty" mapstructure:"ilike,omitempty"`

	// InList corresponds to the JSON schema field "in_list".
	InList *LeafCapability `json:"in_list,omitempty" yaml:"in_list,omitempty" mapstructure:"in_list,omitempty"`

	// IsDistinctFrom corresponds to the JSON schema field "is_distinct_from".
	IsDistinctFrom *LeafCapability `json:"is_distinct_from,omitempty" yaml:"is_distinct_from,omitempty" mapstructure:"is_distinct_from,omitempty"`

	// IsFalse corresponds to the JSON schema field "is_false".
	IsFalse *LeafCapability `json:"is_false,omitempty" yaml:"is_false,omitempty" mapstructure:"is_false,omitempty"`

	// IsNan corresponds to the JSON schema field "is_nan".
	IsNan *LeafCapability `json:"is_nan,omitempty" yaml:"is_nan,omitempty" mapstructure:"is_nan,omitempty"`

	// IsNull corresponds to the JSON schema field "is_null".
	IsNull *LeafCapability `json:"is_null,omitempty" yaml:"is_null,omitempty" mapstructure:"is_null,omitempty"`

	// IsTrue corresponds to the JSON schema field "is_true".
	IsTrue *LeafCapability `json:"is_true,omitempty" yaml:"is_true,omitempty" mapstructure:"is_true,omitempty"`

	// IsZero corresponds to the JSON schema field "is_zero".
	IsZero *LeafCapability `json:"is_zero,omitempty" yaml:"is_zero,omitempty" mapstructure:"is_zero,omitempty"`

	// LessThan corresponds to the JSON schema field "less_than".
	LessThan *LeafCapability `json:"less_than,omitempty" yaml:"less_than,omitempty" mapstructure:"less_than,omitempty"`

	// LessThanEq corresponds to the JSON schema field "less_than_eq".
	LessThanEq *LeafCapability `json:"less_than_eq,omitempty" yaml:"less_than_eq,omitempty" mapstructure:"less_than_eq,omitempty"`

	// Like corresponds to the JSON schema field "like".
	Like *LeafCapability `json:"like,omitempty" yaml:"like,omitempty" mapstructure:"like,omitempty"`
}

type RelationalConditionalExpressionCapabilities struct {
	// Case corresponds to the JSON schema field "case".
	Case *RelationalCaseCapabilities `json:"case,omitempty" yaml:"case,omitempty" mapstructure:"case,omitempty"`

	// Nullif corresponds to the JSON schema field "nullif".
	Nullif *LeafCapability `json:"nullif,omitempty" yaml:"nullif,omitempty" mapstructure:"nullif,omitempty"`
}

type RelationalDeleteRequest struct {
	// Values to be provided to any collection arguments
	Arguments RelationalDeleteRequestArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// The name of the collection to delete from
	Collection string `json:"collection" yaml:"collection" mapstructure:"collection"`

	// The relation that identifies which rows to delete
	Relation Relation `json:"relation" yaml:"relation" mapstructure:"relation"`
}

// Values to be provided to any collection arguments
type RelationalDeleteRequestArguments map[string]Argument

// The relation that identifies which rows to delete

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalDeleteRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in RelationalDeleteRequest: required")
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in RelationalDeleteRequest: required")
	}
	if _, ok := raw["relation"]; raw != nil && !ok {
		return fmt.Errorf("field relation in RelationalDeleteRequest: required")
	}
	type Plain RelationalDeleteRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalDeleteRequest(plain)
	return nil
}

type RelationalDeleteResponse struct {
	// The number of rows that were deleted
	AffectedRows int `json:"affected_rows" yaml:"affected_rows" mapstructure:"affected_rows"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalDeleteResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["affected_rows"]; raw != nil && !ok {
		return fmt.Errorf("field affected_rows in RelationalDeleteResponse: required")
	}
	type Plain RelationalDeleteResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 0 > plain.AffectedRows {
		return fmt.Errorf("field %s: must be >= %v", "affected_rows", 0)
	}
	*j = RelationalDeleteResponse(plain)
	return nil
}

type RelationalExpressionCapabilities struct {
	// Aggregate corresponds to the JSON schema field "aggregate".
	Aggregate RelationalAggregateExpressionCapabilities `json:"aggregate" yaml:"aggregate" mapstructure:"aggregate"`

	// Comparison corresponds to the JSON schema field "comparison".
	Comparison RelationalComparisonExpressionCapabilities `json:"comparison" yaml:"comparison" mapstructure:"comparison"`

	// Conditional corresponds to the JSON schema field "conditional".
	Conditional RelationalConditionalExpressionCapabilities `json:"conditional" yaml:"conditional" mapstructure:"conditional"`

	// Scalar corresponds to the JSON schema field "scalar".
	Scalar RelationalScalarExpressionCapabilities `json:"scalar" yaml:"scalar" mapstructure:"scalar"`

	// ScalarTypes corresponds to the JSON schema field "scalar_types".
	ScalarTypes *RelationalScalarTypeCapabilities `json:"scalar_types,omitempty" yaml:"scalar_types,omitempty" mapstructure:"scalar_types,omitempty"`

	// Window corresponds to the JSON schema field "window".
	Window RelationalWindowExpressionCapabilities `json:"window" yaml:"window" mapstructure:"window"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalExpressionCapabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["aggregate"]; raw != nil && !ok {
		return fmt.Errorf("field aggregate in RelationalExpressionCapabilities: required")
	}
	if _, ok := raw["comparison"]; raw != nil && !ok {
		return fmt.Errorf("field comparison in RelationalExpressionCapabilities: required")
	}
	if _, ok := raw["conditional"]; raw != nil && !ok {
		return fmt.Errorf("field conditional in RelationalExpressionCapabilities: required")
	}
	if _, ok := raw["scalar"]; raw != nil && !ok {
		return fmt.Errorf("field scalar in RelationalExpressionCapabilities: required")
	}
	if _, ok := raw["window"]; raw != nil && !ok {
		return fmt.Errorf("field window in RelationalExpressionCapabilities: required")
	}
	type Plain RelationalExpressionCapabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalExpressionCapabilities(plain)
	return nil
}

type RelationalInsertRequest struct {
	// Values to be provided to any collection arguments
	Arguments RelationalInsertRequestArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// The name of the collection to insert into
	Collection string `json:"collection" yaml:"collection" mapstructure:"collection"`

	// The columns to insert values for
	Columns []string `json:"columns" yaml:"columns" mapstructure:"columns"`

	// The rows to insert, each row containing values for the specified columns
	Rows [][]interface{} `json:"rows" yaml:"rows" mapstructure:"rows"`
}

// Values to be provided to any collection arguments
type RelationalInsertRequestArguments map[string]Argument

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalInsertRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in RelationalInsertRequest: required")
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in RelationalInsertRequest: required")
	}
	if _, ok := raw["columns"]; raw != nil && !ok {
		return fmt.Errorf("field columns in RelationalInsertRequest: required")
	}
	if _, ok := raw["rows"]; raw != nil && !ok {
		return fmt.Errorf("field rows in RelationalInsertRequest: required")
	}
	type Plain RelationalInsertRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalInsertRequest(plain)
	return nil
}

type RelationalInsertResponse struct {
	// The number of rows that were inserted
	AffectedRows int `json:"affected_rows" yaml:"affected_rows" mapstructure:"affected_rows"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalInsertResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["affected_rows"]; raw != nil && !ok {
		return fmt.Errorf("field affected_rows in RelationalInsertResponse: required")
	}
	type Plain RelationalInsertResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 0 > plain.AffectedRows {
		return fmt.Errorf("field %s: must be >= %v", "affected_rows", 0)
	}
	*j = RelationalInsertResponse(plain)
	return nil
}

type RelationalJoinCapabilities struct {
	// Expression corresponds to the JSON schema field "expression".
	Expression RelationalExpressionCapabilities `json:"expression" yaml:"expression" mapstructure:"expression"`

	// JoinTypes corresponds to the JSON schema field "join_types".
	JoinTypes RelationalJoinTypeCapabilities `json:"join_types" yaml:"join_types" mapstructure:"join_types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalJoinCapabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["expression"]; raw != nil && !ok {
		return fmt.Errorf("field expression in RelationalJoinCapabilities: required")
	}
	if _, ok := raw["join_types"]; raw != nil && !ok {
		return fmt.Errorf("field join_types in RelationalJoinCapabilities: required")
	}
	type Plain RelationalJoinCapabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalJoinCapabilities(plain)
	return nil
}

type RelationalJoinTypeCapabilities struct {
	// Full corresponds to the JSON schema field "full".
	Full *LeafCapability `json:"full,omitempty" yaml:"full,omitempty" mapstructure:"full,omitempty"`

	// Inner corresponds to the JSON schema field "inner".
	Inner *LeafCapability `json:"inner,omitempty" yaml:"inner,omitempty" mapstructure:"inner,omitempty"`

	// Left corresponds to the JSON schema field "left".
	Left *LeafCapability `json:"left,omitempty" yaml:"left,omitempty" mapstructure:"left,omitempty"`

	// LeftAnti corresponds to the JSON schema field "left_anti".
	LeftAnti *LeafCapability `json:"left_anti,omitempty" yaml:"left_anti,omitempty" mapstructure:"left_anti,omitempty"`

	// LeftSemi corresponds to the JSON schema field "left_semi".
	LeftSemi *LeafCapability `json:"left_semi,omitempty" yaml:"left_semi,omitempty" mapstructure:"left_semi,omitempty"`

	// Right corresponds to the JSON schema field "right".
	Right *LeafCapability `json:"right,omitempty" yaml:"right,omitempty" mapstructure:"right,omitempty"`

	// RightAnti corresponds to the JSON schema field "right_anti".
	RightAnti *LeafCapability `json:"right_anti,omitempty" yaml:"right_anti,omitempty" mapstructure:"right_anti,omitempty"`

	// RightSemi corresponds to the JSON schema field "right_semi".
	RightSemi *LeafCapability `json:"right_semi,omitempty" yaml:"right_semi,omitempty" mapstructure:"right_semi,omitempty"`
}

// Describes which features of the relational mutation API are supported by the
// connector. This feature is experimental and subject to breaking changes within
// minor versions.
type RelationalMutationCapabilities struct {
	// Delete corresponds to the JSON schema field "delete".
	Delete *LeafCapability `json:"delete,omitempty" yaml:"delete,omitempty" mapstructure:"delete,omitempty"`

	// Insert corresponds to the JSON schema field "insert".
	Insert *LeafCapability `json:"insert,omitempty" yaml:"insert,omitempty" mapstructure:"insert,omitempty"`

	// Update corresponds to the JSON schema field "update".
	Update *LeafCapability `json:"update,omitempty" yaml:"update,omitempty" mapstructure:"update,omitempty"`
}

type RelationalMutationInfo struct {
	// Whether deletes are supported for this collection
	Deletable bool `json:"deletable" yaml:"deletable" mapstructure:"deletable"`

	// Whether inserts are supported for this collection
	Insertable bool `json:"insertable" yaml:"insertable" mapstructure:"insertable"`

	// Whether updates are supported for this collection
	Updatable bool `json:"updatable" yaml:"updatable" mapstructure:"updatable"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalMutationInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["deletable"]; raw != nil && !ok {
		return fmt.Errorf("field deletable in RelationalMutationInfo: required")
	}
	if _, ok := raw["insertable"]; raw != nil && !ok {
		return fmt.Errorf("field insertable in RelationalMutationInfo: required")
	}
	if _, ok := raw["updatable"]; raw != nil && !ok {
		return fmt.Errorf("field updatable in RelationalMutationInfo: required")
	}
	type Plain RelationalMutationInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalMutationInfo(plain)
	return nil
}

type RelationalOrderedAggregateFunctionCapabilities struct {
	// Distinct corresponds to the JSON schema field "distinct".
	Distinct *LeafCapability `json:"distinct,omitempty" yaml:"distinct,omitempty" mapstructure:"distinct,omitempty"`

	// OrderBy corresponds to the JSON schema field "order_by".
	OrderBy *LeafCapability `json:"order_by" yaml:"order_by" mapstructure:"order_by"`
}

type RelationalProjectionCapabilities struct {
	// Expression corresponds to the JSON schema field "expression".
	Expression RelationalExpressionCapabilities `json:"expression" yaml:"expression" mapstructure:"expression"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalProjectionCapabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["expression"]; raw != nil && !ok {
		return fmt.Errorf("field expression in RelationalProjectionCapabilities: required")
	}
	type Plain RelationalProjectionCapabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalProjectionCapabilities(plain)
	return nil
}

type RelationalQuery struct {
	// Values to be provided to request-level arguments.
	RequestArguments RelationalQueryRequestArguments `json:"request_arguments,omitempty" yaml:"request_arguments,omitempty" mapstructure:"request_arguments,omitempty"`

	// RootRelation corresponds to the JSON schema field "root_relation".
	RootRelation Relation `json:"root_relation" yaml:"root_relation" mapstructure:"root_relation"`
}

// Describes which features of the relational query API are supported by the
// connector. This feature is experimental and subject to breaking changes within
// minor versions.
type RelationalQueryCapabilities struct {
	// Aggregate corresponds to the JSON schema field "aggregate".
	Aggregate *LeafCapability `json:"aggregate,omitempty" yaml:"aggregate,omitempty" mapstructure:"aggregate,omitempty"`

	// Filter corresponds to the JSON schema field "filter".
	Filter *LeafCapability `json:"filter,omitempty" yaml:"filter,omitempty" mapstructure:"filter,omitempty"`

	// Join corresponds to the JSON schema field "join".
	Join *LeafCapability `json:"join,omitempty" yaml:"join,omitempty" mapstructure:"join,omitempty"`

	// Project corresponds to the JSON schema field "project".
	Project RelationalProjectionCapabilities `json:"project" yaml:"project" mapstructure:"project"`

	// Sort corresponds to the JSON schema field "sort".
	Sort *LeafCapability `json:"sort,omitempty" yaml:"sort,omitempty" mapstructure:"sort,omitempty"`

	// Union corresponds to the JSON schema field "union".
	Union *LeafCapability `json:"union,omitempty" yaml:"union,omitempty" mapstructure:"union,omitempty"`

	// Window corresponds to the JSON schema field "window".
	Window *LeafCapability `json:"window,omitempty" yaml:"window,omitempty" mapstructure:"window,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalQueryCapabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["project"]; raw != nil && !ok {
		return fmt.Errorf("field project in RelationalQueryCapabilities: required")
	}
	type Plain RelationalQueryCapabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalQueryCapabilities(plain)
	return nil
}

// Values to be provided to request-level arguments.
type RelationalQueryRequestArguments map[string]Argument

type RelationalQueryResponse struct {
	// Rows corresponds to the JSON schema field "rows".
	Rows [][]interface{} `json:"rows" yaml:"rows" mapstructure:"rows"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalQueryResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["rows"]; raw != nil && !ok {
		return fmt.Errorf("field rows in RelationalQueryResponse: required")
	}
	type Plain RelationalQueryResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalQueryResponse(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalQuery) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["root_relation"]; raw != nil && !ok {
		return fmt.Errorf("field root_relation in RelationalQuery: required")
	}
	type Plain RelationalQuery
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalQuery(plain)
	return nil
}

type RelationalScalarExpressionCapabilities struct {
	// Abs corresponds to the JSON schema field "abs".
	Abs *LeafCapability `json:"abs,omitempty" yaml:"abs,omitempty" mapstructure:"abs,omitempty"`

	// And corresponds to the JSON schema field "and".
	And *LeafCapability `json:"and,omitempty" yaml:"and,omitempty" mapstructure:"and,omitempty"`

	// ArrayElement corresponds to the JSON schema field "array_element".
	ArrayElement *LeafCapability `json:"array_element,omitempty" yaml:"array_element,omitempty" mapstructure:"array_element,omitempty"`

	// BinaryConcat corresponds to the JSON schema field "binary_concat".
	BinaryConcat *LeafCapability `json:"binary_concat,omitempty" yaml:"binary_concat,omitempty" mapstructure:"binary_concat,omitempty"`

	// Btrim corresponds to the JSON schema field "btrim".
	Btrim *LeafCapability `json:"btrim,omitempty" yaml:"btrim,omitempty" mapstructure:"btrim,omitempty"`

	// Ceil corresponds to the JSON schema field "ceil".
	Ceil *LeafCapability `json:"ceil,omitempty" yaml:"ceil,omitempty" mapstructure:"ceil,omitempty"`

	// CharacterLength corresponds to the JSON schema field "character_length".
	CharacterLength *LeafCapability `json:"character_length,omitempty" yaml:"character_length,omitempty" mapstructure:"character_length,omitempty"`

	// Coalesce corresponds to the JSON schema field "coalesce".
	Coalesce *LeafCapability `json:"coalesce,omitempty" yaml:"coalesce,omitempty" mapstructure:"coalesce,omitempty"`

	// Concat corresponds to the JSON schema field "concat".
	Concat *LeafCapability `json:"concat,omitempty" yaml:"concat,omitempty" mapstructure:"concat,omitempty"`

	// Cos corresponds to the JSON schema field "cos".
	Cos *LeafCapability `json:"cos,omitempty" yaml:"cos,omitempty" mapstructure:"cos,omitempty"`

	// CurrentDate corresponds to the JSON schema field "current_date".
	CurrentDate *LeafCapability `json:"current_date,omitempty" yaml:"current_date,omitempty" mapstructure:"current_date,omitempty"`

	// CurrentTime corresponds to the JSON schema field "current_time".
	CurrentTime *LeafCapability `json:"current_time,omitempty" yaml:"current_time,omitempty" mapstructure:"current_time,omitempty"`

	// CurrentTimestamp corresponds to the JSON schema field "current_timestamp".
	CurrentTimestamp *LeafCapability `json:"current_timestamp,omitempty" yaml:"current_timestamp,omitempty" mapstructure:"current_timestamp,omitempty"`

	// DatePart corresponds to the JSON schema field "date_part".
	DatePart *LeafCapability `json:"date_part,omitempty" yaml:"date_part,omitempty" mapstructure:"date_part,omitempty"`

	// DateTrunc corresponds to the JSON schema field "date_trunc".
	DateTrunc *LeafCapability `json:"date_trunc,omitempty" yaml:"date_trunc,omitempty" mapstructure:"date_trunc,omitempty"`

	// Divide corresponds to the JSON schema field "divide".
	Divide *LeafCapability `json:"divide,omitempty" yaml:"divide,omitempty" mapstructure:"divide,omitempty"`

	// Exp corresponds to the JSON schema field "exp".
	Exp *LeafCapability `json:"exp,omitempty" yaml:"exp,omitempty" mapstructure:"exp,omitempty"`

	// Floor corresponds to the JSON schema field "floor".
	Floor *LeafCapability `json:"floor,omitempty" yaml:"floor,omitempty" mapstructure:"floor,omitempty"`

	// GetField corresponds to the JSON schema field "get_field".
	GetField *LeafCapability `json:"get_field,omitempty" yaml:"get_field,omitempty" mapstructure:"get_field,omitempty"`

	// Greatest corresponds to the JSON schema field "greatest".
	Greatest *LeafCapability `json:"greatest,omitempty" yaml:"greatest,omitempty" mapstructure:"greatest,omitempty"`

	// Least corresponds to the JSON schema field "least".
	Least *LeafCapability `json:"least,omitempty" yaml:"least,omitempty" mapstructure:"least,omitempty"`

	// Left corresponds to the JSON schema field "left".
	Left *LeafCapability `json:"left,omitempty" yaml:"left,omitempty" mapstructure:"left,omitempty"`

	// Ln corresponds to the JSON schema field "ln".
	Ln *LeafCapability `json:"ln,omitempty" yaml:"ln,omitempty" mapstructure:"ln,omitempty"`

	// Log corresponds to the JSON schema field "log".
	Log *LeafCapability `json:"log,omitempty" yaml:"log,omitempty" mapstructure:"log,omitempty"`

	// Log10 corresponds to the JSON schema field "log10".
	Log10 *LeafCapability `json:"log10,omitempty" yaml:"log10,omitempty" mapstructure:"log10,omitempty"`

	// Log2 corresponds to the JSON schema field "log2".
	Log2 *LeafCapability `json:"log2,omitempty" yaml:"log2,omitempty" mapstructure:"log2,omitempty"`

	// Lpad corresponds to the JSON schema field "lpad".
	Lpad *LeafCapability `json:"lpad,omitempty" yaml:"lpad,omitempty" mapstructure:"lpad,omitempty"`

	// Ltrim corresponds to the JSON schema field "ltrim".
	Ltrim *LeafCapability `json:"ltrim,omitempty" yaml:"ltrim,omitempty" mapstructure:"ltrim,omitempty"`

	// Minus corresponds to the JSON schema field "minus".
	Minus *LeafCapability `json:"minus,omitempty" yaml:"minus,omitempty" mapstructure:"minus,omitempty"`

	// Modulo corresponds to the JSON schema field "modulo".
	Modulo *LeafCapability `json:"modulo,omitempty" yaml:"modulo,omitempty" mapstructure:"modulo,omitempty"`

	// Multiply corresponds to the JSON schema field "multiply".
	Multiply *LeafCapability `json:"multiply,omitempty" yaml:"multiply,omitempty" mapstructure:"multiply,omitempty"`

	// Negate corresponds to the JSON schema field "negate".
	Negate *LeafCapability `json:"negate,omitempty" yaml:"negate,omitempty" mapstructure:"negate,omitempty"`

	// Not corresponds to the JSON schema field "not".
	Not *LeafCapability `json:"not,omitempty" yaml:"not,omitempty" mapstructure:"not,omitempty"`

	// Nvl corresponds to the JSON schema field "nvl".
	Nvl *LeafCapability `json:"nvl,omitempty" yaml:"nvl,omitempty" mapstructure:"nvl,omitempty"`

	// Or corresponds to the JSON schema field "or".
	Or *LeafCapability `json:"or,omitempty" yaml:"or,omitempty" mapstructure:"or,omitempty"`

	// Plus corresponds to the JSON schema field "plus".
	Plus *LeafCapability `json:"plus,omitempty" yaml:"plus,omitempty" mapstructure:"plus,omitempty"`

	// Power corresponds to the JSON schema field "power".
	Power *LeafCapability `json:"power,omitempty" yaml:"power,omitempty" mapstructure:"power,omitempty"`

	// Random corresponds to the JSON schema field "random".
	Random *LeafCapability `json:"random,omitempty" yaml:"random,omitempty" mapstructure:"random,omitempty"`

	// Replace corresponds to the JSON schema field "replace".
	Replace *LeafCapability `json:"replace,omitempty" yaml:"replace,omitempty" mapstructure:"replace,omitempty"`

	// Reverse corresponds to the JSON schema field "reverse".
	Reverse *LeafCapability `json:"reverse,omitempty" yaml:"reverse,omitempty" mapstructure:"reverse,omitempty"`

	// Right corresponds to the JSON schema field "right".
	Right *LeafCapability `json:"right,omitempty" yaml:"right,omitempty" mapstructure:"right,omitempty"`

	// Round corresponds to the JSON schema field "round".
	Round *LeafCapability `json:"round,omitempty" yaml:"round,omitempty" mapstructure:"round,omitempty"`

	// Rpad corresponds to the JSON schema field "rpad".
	Rpad *LeafCapability `json:"rpad,omitempty" yaml:"rpad,omitempty" mapstructure:"rpad,omitempty"`

	// Rtrim corresponds to the JSON schema field "rtrim".
	Rtrim *LeafCapability `json:"rtrim,omitempty" yaml:"rtrim,omitempty" mapstructure:"rtrim,omitempty"`

	// Sqrt corresponds to the JSON schema field "sqrt".
	Sqrt *LeafCapability `json:"sqrt,omitempty" yaml:"sqrt,omitempty" mapstructure:"sqrt,omitempty"`

	// StrPos corresponds to the JSON schema field "str_pos".
	StrPos *LeafCapability `json:"str_pos,omitempty" yaml:"str_pos,omitempty" mapstructure:"str_pos,omitempty"`

	// Substr corresponds to the JSON schema field "substr".
	Substr *LeafCapability `json:"substr,omitempty" yaml:"substr,omitempty" mapstructure:"substr,omitempty"`

	// SubstrIndex corresponds to the JSON schema field "substr_index".
	SubstrIndex *LeafCapability `json:"substr_index,omitempty" yaml:"substr_index,omitempty" mapstructure:"substr_index,omitempty"`

	// Tan corresponds to the JSON schema field "tan".
	Tan *LeafCapability `json:"tan,omitempty" yaml:"tan,omitempty" mapstructure:"tan,omitempty"`

	// ToDate corresponds to the JSON schema field "to_date".
	ToDate *LeafCapability `json:"to_date,omitempty" yaml:"to_date,omitempty" mapstructure:"to_date,omitempty"`

	// ToLower corresponds to the JSON schema field "to_lower".
	ToLower *LeafCapability `json:"to_lower,omitempty" yaml:"to_lower,omitempty" mapstructure:"to_lower,omitempty"`

	// ToTimestamp corresponds to the JSON schema field "to_timestamp".
	ToTimestamp *LeafCapability `json:"to_timestamp,omitempty" yaml:"to_timestamp,omitempty" mapstructure:"to_timestamp,omitempty"`

	// ToUpper corresponds to the JSON schema field "to_upper".
	ToUpper *LeafCapability `json:"to_upper,omitempty" yaml:"to_upper,omitempty" mapstructure:"to_upper,omitempty"`

	// Trunc corresponds to the JSON schema field "trunc".
	Trunc *LeafCapability `json:"trunc,omitempty" yaml:"trunc,omitempty" mapstructure:"trunc,omitempty"`
}

type RelationalScalarTypeCapabilities struct {
	// Does the connector support `from_type` in cast?
	FromType *LeafCapability `json:"from_type,omitempty" yaml:"from_type,omitempty" mapstructure:"from_type,omitempty"`

	// Does the connector support the INTERVAL scalar type? Both interval literals and
	// casts to the INTERVAL type are implied by this capability.
	Interval *LeafCapability `json:"interval,omitempty" yaml:"interval,omitempty" mapstructure:"interval,omitempty"`
}

type RelationalSortCapabilities struct {
	// Expression corresponds to the JSON schema field "expression".
	Expression RelationalExpressionCapabilities `json:"expression" yaml:"expression" mapstructure:"expression"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalSortCapabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["expression"]; raw != nil && !ok {
		return fmt.Errorf("field expression in RelationalSortCapabilities: required")
	}
	type Plain RelationalSortCapabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalSortCapabilities(plain)
	return nil
}

type RelationalUpdateRequest struct {
	// Values to be provided to any collection arguments
	Arguments RelationalUpdateRequestArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// The name of the collection to update
	Collection string `json:"collection" yaml:"collection" mapstructure:"collection"`

	// The relation that identifies which rows to update
	Relation Relation `json:"relation" yaml:"relation" mapstructure:"relation"`
}

// Values to be provided to any collection arguments
type RelationalUpdateRequestArguments map[string]Argument

// The relation that identifies which rows to update

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalUpdateRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in RelationalUpdateRequest: required")
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in RelationalUpdateRequest: required")
	}
	if _, ok := raw["relation"]; raw != nil && !ok {
		return fmt.Errorf("field relation in RelationalUpdateRequest: required")
	}
	type Plain RelationalUpdateRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalUpdateRequest(plain)
	return nil
}

type RelationalUpdateResponse struct {
	// The number of rows that were updated
	AffectedRows int `json:"affected_rows" yaml:"affected_rows" mapstructure:"affected_rows"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalUpdateResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["affected_rows"]; raw != nil && !ok {
		return fmt.Errorf("field affected_rows in RelationalUpdateResponse: required")
	}
	type Plain RelationalUpdateResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 0 > plain.AffectedRows {
		return fmt.Errorf("field %s: must be >= %v", "affected_rows", 0)
	}
	*j = RelationalUpdateResponse(plain)
	return nil
}

type RelationalWindowCapabilities struct {
	// Expression corresponds to the JSON schema field "expression".
	Expression RelationalExpressionCapabilities `json:"expression" yaml:"expression" mapstructure:"expression"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationalWindowCapabilities) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["expression"]; raw != nil && !ok {
		return fmt.Errorf("field expression in RelationalWindowCapabilities: required")
	}
	type Plain RelationalWindowCapabilities
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RelationalWindowCapabilities(plain)
	return nil
}

type RelationalWindowExpressionCapabilities struct {
	// CumeDist corresponds to the JSON schema field "cume_dist".
	CumeDist *LeafCapability `json:"cume_dist,omitempty" yaml:"cume_dist,omitempty" mapstructure:"cume_dist,omitempty"`

	// DenseRank corresponds to the JSON schema field "dense_rank".
	DenseRank *LeafCapability `json:"dense_rank,omitempty" yaml:"dense_rank,omitempty" mapstructure:"dense_rank,omitempty"`

	// Ntile corresponds to the JSON schema field "ntile".
	Ntile *LeafCapability `json:"ntile,omitempty" yaml:"ntile,omitempty" mapstructure:"ntile,omitempty"`

	// PercentRank corresponds to the JSON schema field "percent_rank".
	PercentRank *LeafCapability `json:"percent_rank,omitempty" yaml:"percent_rank,omitempty" mapstructure:"percent_rank,omitempty"`

	// Rank corresponds to the JSON schema field "rank".
	Rank *LeafCapability `json:"rank,omitempty" yaml:"rank,omitempty" mapstructure:"rank,omitempty"`

	// RowNumber corresponds to the JSON schema field "row_number".
	RowNumber *LeafCapability `json:"row_number,omitempty" yaml:"row_number,omitempty" mapstructure:"row_number,omitempty"`
}

type Relationship struct {
	// Values to be provided to any collection arguments
	Arguments RelationshipArguments `json:"arguments" yaml:"arguments" mapstructure:"arguments"`

	// A mapping between columns on the source row to columns on the target
	// collection. The column on the target collection is specified via a field path
	// (ie. an array of field names that descend through nested object fields). The
	// field path will only contain a single item, meaning a column on the target
	// collection's type, unless the 'relationships.nested' capability is supported,
	// in which case multiple items denotes a nested object field.
	ColumnMapping RelationshipColumnMapping `json:"column_mapping" yaml:"column_mapping" mapstructure:"column_mapping"`

	// RelationshipType corresponds to the JSON schema field "relationship_type".
	RelationshipType RelationshipType `json:"relationship_type" yaml:"relationship_type" mapstructure:"relationship_type"`

	// The name of a collection
	TargetCollection string `json:"target_collection" yaml:"target_collection" mapstructure:"target_collection"`
}

// Values to be provided to any collection arguments
type RelationshipArguments map[string]RelationshipArgument

type RelationshipCapabilities struct {
	// Does the connector support navigating a relationship from inside a nested
	// object
	Nested *NestedRelationshipCapabilities `json:"nested,omitempty" yaml:"nested,omitempty" mapstructure:"nested,omitempty"`

	// Does the connector support ordering by an aggregated array relationship?
	OrderByAggregate *LeafCapability `json:"order_by_aggregate" yaml:"order_by_aggregate" mapstructure:"order_by_aggregate"`

	// Does the connector support comparisons that involve related collections (ie.
	// joins)?
	RelationComparisons *LeafCapability `json:"relation_comparisons" yaml:"relation_comparisons" mapstructure:"relation_comparisons"`
}

// A mapping between columns on the source row to columns on the target collection.
// The column on the target collection is specified via a field path (ie. an array
// of field names that descend through nested object fields). The field path will
// only contain a single item, meaning a column on the target collection's type,
// unless the 'relationships.nested' capability is supported, in which case
// multiple items denotes a nested object field.
type RelationshipColumnMapping map[string][]string

type RelationshipType string

const RelationshipTypeArray RelationshipType = "array"
const RelationshipTypeObject RelationshipType = "object"

var enumValues_RelationshipType = []interface{}{
	"object",
	"array",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelationshipType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RelationshipType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RelationshipType, v)
	}
	*j = RelationshipType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Relationship) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["arguments"]; raw != nil && !ok {
		return fmt.Errorf("field arguments in Relationship: required")
	}
	if _, ok := raw["column_mapping"]; raw != nil && !ok {
		return fmt.Errorf("field column_mapping in Relationship: required")
	}
	if _, ok := raw["relationship_type"]; raw != nil && !ok {
		return fmt.Errorf("field relationship_type in Relationship: required")
	}
	if _, ok := raw["target_collection"]; raw != nil && !ok {
		return fmt.Errorf("field target_collection in Relationship: required")
	}
	type Plain Relationship
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Relationship(plain)
	return nil
}

type RequestLevelArguments struct {
	// Any arguments that all Mutation requests require
	MutationArguments RequestLevelArgumentsMutationArguments `json:"mutation_arguments" yaml:"mutation_arguments" mapstructure:"mutation_arguments"`

	// Any arguments that all Query requests require
	QueryArguments RequestLevelArgumentsQueryArguments `json:"query_arguments" yaml:"query_arguments" mapstructure:"query_arguments"`

	// Any arguments that all Relational Query requests require
	RelationalQueryArguments RequestLevelArgumentsRelationalQueryArguments `json:"relational_query_arguments" yaml:"relational_query_arguments" mapstructure:"relational_query_arguments"`
}

// Any arguments that all Mutation requests require
type RequestLevelArgumentsMutationArguments map[string]ArgumentInfo

// Any arguments that all Query requests require
type RequestLevelArgumentsQueryArguments map[string]ArgumentInfo

// Any arguments that all Relational Query requests require
type RequestLevelArgumentsRelationalQueryArguments map[string]ArgumentInfo

// UnmarshalJSON implements json.Unmarshaler.
func (j *RequestLevelArguments) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["mutation_arguments"]; raw != nil && !ok {
		return fmt.Errorf("field mutation_arguments in RequestLevelArguments: required")
	}
	if _, ok := raw["query_arguments"]; raw != nil && !ok {
		return fmt.Errorf("field query_arguments in RequestLevelArguments: required")
	}
	if _, ok := raw["relational_query_arguments"]; raw != nil && !ok {
		return fmt.Errorf("field relational_query_arguments in RequestLevelArguments: required")
	}
	type Plain RequestLevelArguments
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RequestLevelArguments(plain)
	return nil
}

type RowSet struct {
	// The results of the aggregates returned by the query
	Aggregates RowSetAggregates `json:"aggregates,omitempty" yaml:"aggregates,omitempty" mapstructure:"aggregates,omitempty"`

	// The results of any grouping operation
	Groups []Group `json:"groups,omitempty" yaml:"groups,omitempty" mapstructure:"groups,omitempty"`

	// The rows returned by the query, corresponding to the query's fields
	Rows []map[string]any `json:"rows,omitempty" yaml:"rows,omitempty" mapstructure:"rows,omitempty"`
}

// The results of the aggregates returned by the query
type RowSetAggregates map[string]interface{}

// The definition of a scalar type, i.e. types that can be used as the types of
// columns.
type ScalarType struct {
	// A map from aggregate function names to their definitions. Result type names
	// must be defined scalar types declared in ScalarTypesCapabilities.
	AggregateFunctions ScalarTypeAggregateFunctions `json:"aggregate_functions" yaml:"aggregate_functions" mapstructure:"aggregate_functions"`

	// A map from comparison operator names to their definitions. Argument type names
	// must be defined scalar types declared in ScalarTypesCapabilities.
	ComparisonOperators map[string]ComparisonOperatorDefinition `json:"comparison_operators" yaml:"comparison_operators" mapstructure:"comparison_operators"`

	// A map from extraction function names to their definitions.
	ExtractionFunctions ScalarTypeExtractionFunctions `json:"extraction_functions,omitempty" yaml:"extraction_functions,omitempty" mapstructure:"extraction_functions,omitempty"`

	// A description of valid values for this scalar type.
	Representation TypeRepresentation `json:"representation" yaml:"representation" mapstructure:"representation"`
}

// A map from aggregate function names to their definitions. Result type names must
// be defined scalar types declared in ScalarTypesCapabilities.
type ScalarTypeAggregateFunctions map[string]AggregateFunctionDefinition

// A map from comparison operator names to their definitions. Argument type names
// must be defined scalar types declared in ScalarTypesCapabilities.

// A map from extraction function names to their definitions.
type ScalarTypeExtractionFunctions map[string]ExtractionFunctionDefinition

// UnmarshalJSON implements json.Unmarshaler.
func (j *ScalarType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["aggregate_functions"]; raw != nil && !ok {
		return fmt.Errorf("field aggregate_functions in ScalarType: required")
	}
	if _, ok := raw["comparison_operators"]; raw != nil && !ok {
		return fmt.Errorf("field comparison_operators in ScalarType: required")
	}
	if _, ok := raw["representation"]; raw != nil && !ok {
		return fmt.Errorf("field representation in ScalarType: required")
	}
	type Plain ScalarType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["extraction_functions"]; !ok || v == nil {
		plain.ExtractionFunctions = map[string]ExtractionFunctionDefinition{}
	}
	*j = ScalarType(plain)
	return nil
}

type SchemaPatchedJson struct {
	// CapabilitiesResponse corresponds to the JSON schema field
	// "capabilities_response".
	CapabilitiesResponse CapabilitiesResponse `json:"capabilities_response" yaml:"capabilities_response" mapstructure:"capabilities_response"`

	// ErrorResponse corresponds to the JSON schema field "error_response".
	ErrorResponse ErrorResponse `json:"error_response" yaml:"error_response" mapstructure:"error_response"`

	// ExplainResponse corresponds to the JSON schema field "explain_response".
	ExplainResponse ExplainResponse `json:"explain_response" yaml:"explain_response" mapstructure:"explain_response"`

	// MutationRequest corresponds to the JSON schema field "mutation_request".
	MutationRequest MutationRequest `json:"mutation_request" yaml:"mutation_request" mapstructure:"mutation_request"`

	// MutationResponse corresponds to the JSON schema field "mutation_response".
	MutationResponse MutationResponse `json:"mutation_response" yaml:"mutation_response" mapstructure:"mutation_response"`

	// QueryRequest corresponds to the JSON schema field "query_request".
	QueryRequest QueryRequest `json:"query_request" yaml:"query_request" mapstructure:"query_request"`

	// QueryResponse corresponds to the JSON schema field "query_response".
	QueryResponse QueryResponse `json:"query_response" yaml:"query_response" mapstructure:"query_response"`

	// RelationalDeleteRequest corresponds to the JSON schema field
	// "relational_delete_request".
	RelationalDeleteRequest RelationalDeleteRequest `json:"relational_delete_request" yaml:"relational_delete_request" mapstructure:"relational_delete_request"`

	// RelationalDeleteResponse corresponds to the JSON schema field
	// "relational_delete_response".
	RelationalDeleteResponse RelationalDeleteResponse `json:"relational_delete_response" yaml:"relational_delete_response" mapstructure:"relational_delete_response"`

	// RelationalInsertRequest corresponds to the JSON schema field
	// "relational_insert_request".
	RelationalInsertRequest RelationalInsertRequest `json:"relational_insert_request" yaml:"relational_insert_request" mapstructure:"relational_insert_request"`

	// RelationalInsertResponse corresponds to the JSON schema field
	// "relational_insert_response".
	RelationalInsertResponse RelationalInsertResponse `json:"relational_insert_response" yaml:"relational_insert_response" mapstructure:"relational_insert_response"`

	// RelationalQuery corresponds to the JSON schema field "relational_query".
	RelationalQuery RelationalQuery `json:"relational_query" yaml:"relational_query" mapstructure:"relational_query"`

	// RelationalQueryResponse corresponds to the JSON schema field
	// "relational_query_response".
	RelationalQueryResponse RelationalQueryResponse `json:"relational_query_response" yaml:"relational_query_response" mapstructure:"relational_query_response"`

	// RelationalUpdateRequest corresponds to the JSON schema field
	// "relational_update_request".
	RelationalUpdateRequest RelationalUpdateRequest `json:"relational_update_request" yaml:"relational_update_request" mapstructure:"relational_update_request"`

	// RelationalUpdateResponse corresponds to the JSON schema field
	// "relational_update_response".
	RelationalUpdateResponse RelationalUpdateResponse `json:"relational_update_response" yaml:"relational_update_response" mapstructure:"relational_update_response"`

	// SchemaResponse corresponds to the JSON schema field "schema_response".
	SchemaResponse SchemaResponse `json:"schema_response" yaml:"schema_response" mapstructure:"schema_response"`

	// ValidateResponse corresponds to the JSON schema field "validate_response".
	ValidateResponse ValidateResponse `json:"validate_response" yaml:"validate_response" mapstructure:"validate_response"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaPatchedJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["capabilities_response"]; raw != nil && !ok {
		return fmt.Errorf("field capabilities_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["error_response"]; raw != nil && !ok {
		return fmt.Errorf("field error_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["explain_response"]; raw != nil && !ok {
		return fmt.Errorf("field explain_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["mutation_request"]; raw != nil && !ok {
		return fmt.Errorf("field mutation_request in SchemaPatchedJson: required")
	}
	if _, ok := raw["mutation_response"]; raw != nil && !ok {
		return fmt.Errorf("field mutation_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["query_request"]; raw != nil && !ok {
		return fmt.Errorf("field query_request in SchemaPatchedJson: required")
	}
	if _, ok := raw["query_response"]; raw != nil && !ok {
		return fmt.Errorf("field query_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["relational_delete_request"]; raw != nil && !ok {
		return fmt.Errorf("field relational_delete_request in SchemaPatchedJson: required")
	}
	if _, ok := raw["relational_delete_response"]; raw != nil && !ok {
		return fmt.Errorf("field relational_delete_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["relational_insert_request"]; raw != nil && !ok {
		return fmt.Errorf("field relational_insert_request in SchemaPatchedJson: required")
	}
	if _, ok := raw["relational_insert_response"]; raw != nil && !ok {
		return fmt.Errorf("field relational_insert_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["relational_query"]; raw != nil && !ok {
		return fmt.Errorf("field relational_query in SchemaPatchedJson: required")
	}
	if _, ok := raw["relational_query_response"]; raw != nil && !ok {
		return fmt.Errorf("field relational_query_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["relational_update_request"]; raw != nil && !ok {
		return fmt.Errorf("field relational_update_request in SchemaPatchedJson: required")
	}
	if _, ok := raw["relational_update_response"]; raw != nil && !ok {
		return fmt.Errorf("field relational_update_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["schema_response"]; raw != nil && !ok {
		return fmt.Errorf("field schema_response in SchemaPatchedJson: required")
	}
	if _, ok := raw["validate_response"]; raw != nil && !ok {
		return fmt.Errorf("field validate_response in SchemaPatchedJson: required")
	}
	type Plain SchemaPatchedJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaPatchedJson(plain)
	return nil
}

type SchemaResponse struct {
	// Schema data which is relevant to features enabled by capabilities
	Capabilities *CapabilitySchemaInfo `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Collections which are available for queries
	Collections []CollectionInfo `json:"collections" yaml:"collections" mapstructure:"collections"`

	// Functions (i.e. collections which return a single column and row)
	Functions []FunctionInfo `json:"functions" yaml:"functions" mapstructure:"functions"`

	// A list of object types which can be used as the types of arguments, or return
	// types of procedures. Names should not overlap with scalar type names.
	ObjectTypes SchemaResponseObjectTypes `json:"object_types" yaml:"object_types" mapstructure:"object_types"`

	// Procedures which are available for execution as part of mutations
	Procedures []ProcedureInfo `json:"procedures" yaml:"procedures" mapstructure:"procedures"`

	// Request level arguments which are required for queries and mutations
	RequestArguments *RequestLevelArguments `json:"request_arguments,omitempty" yaml:"request_arguments,omitempty" mapstructure:"request_arguments,omitempty"`

	// A list of scalar types which will be used as the types of collection columns
	ScalarTypes SchemaResponseScalarTypes `json:"scalar_types" yaml:"scalar_types" mapstructure:"scalar_types"`
}

// A list of object types which can be used as the types of arguments, or return
// types of procedures. Names should not overlap with scalar type names.
type SchemaResponseObjectTypes map[string]ObjectType

// A list of scalar types which will be used as the types of collection columns
type SchemaResponseScalarTypes map[string]ScalarType

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collections"]; raw != nil && !ok {
		return fmt.Errorf("field collections in SchemaResponse: required")
	}
	if _, ok := raw["functions"]; raw != nil && !ok {
		return fmt.Errorf("field functions in SchemaResponse: required")
	}
	if _, ok := raw["object_types"]; raw != nil && !ok {
		return fmt.Errorf("field object_types in SchemaResponse: required")
	}
	if _, ok := raw["procedures"]; raw != nil && !ok {
		return fmt.Errorf("field procedures in SchemaResponse: required")
	}
	if _, ok := raw["scalar_types"]; raw != nil && !ok {
		return fmt.Errorf("field scalar_types in SchemaResponse: required")
	}
	type Plain SchemaResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaResponse(plain)
	return nil
}

type Sort struct {
	// Direction corresponds to the JSON schema field "direction".
	Direction OrderDirection `json:"direction" yaml:"direction" mapstructure:"direction"`

	// Expr corresponds to the JSON schema field "expr".
	Expr RelationalExpression `json:"expr" yaml:"expr" mapstructure:"expr"`

	// NullsSort corresponds to the JSON schema field "nulls_sort".
	NullsSort NullsSort `json:"nulls_sort" yaml:"nulls_sort" mapstructure:"nulls_sort"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sort) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["direction"]; raw != nil && !ok {
		return fmt.Errorf("field direction in Sort: required")
	}
	if _, ok := raw["expr"]; raw != nil && !ok {
		return fmt.Errorf("field expr in Sort: required")
	}
	if _, ok := raw["nulls_sort"]; raw != nil && !ok {
		return fmt.Errorf("field nulls_sort in Sort: required")
	}
	type Plain Sort
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Sort(plain)
	return nil
}

// Types track the valid representations of values as JSON

// Representations of scalar types

type UnaryComparisonOperator string

const UnaryComparisonOperatorIsNull UnaryComparisonOperator = "is_null"

var enumValues_UnaryComparisonOperator = []UnaryComparisonOperator{
	"is_null",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnaryComparisonOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UnaryComparisonOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UnaryComparisonOperator, v)
	}
	*j = UnaryComparisonOperator(v)
	return nil
}

type UniquenessConstraint struct {
	// A list of columns which this constraint requires to be unique
	UniqueColumns []string `json:"unique_columns" yaml:"unique_columns" mapstructure:"unique_columns"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UniquenessConstraint) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["unique_columns"]; raw != nil && !ok {
		return fmt.Errorf("field unique_columns in UniquenessConstraint: required")
	}
	type Plain UniquenessConstraint
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UniquenessConstraint(plain)
	return nil
}

type ValidateResponse struct {
	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities CapabilitiesResponse `json:"capabilities" yaml:"capabilities" mapstructure:"capabilities"`

	// ResolvedConfiguration corresponds to the JSON schema field
	// "resolved_configuration".
	ResolvedConfiguration string `json:"resolved_configuration" yaml:"resolved_configuration" mapstructure:"resolved_configuration"`

	// Schema corresponds to the JSON schema field "schema".
	Schema SchemaResponse `json:"schema" yaml:"schema" mapstructure:"schema"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ValidateResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["capabilities"]; raw != nil && !ok {
		return fmt.Errorf("field capabilities in ValidateResponse: required")
	}
	if _, ok := raw["resolved_configuration"]; raw != nil && !ok {
		return fmt.Errorf("field resolved_configuration in ValidateResponse: required")
	}
	if _, ok := raw["schema"]; raw != nil && !ok {
		return fmt.Errorf("field schema in ValidateResponse: required")
	}
	type Plain ValidateResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ValidateResponse(plain)
	return nil
}
